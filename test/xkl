}

// Namespace: Org.BouncyCastle.Crypto
public class BufferedAeadBlockCipher : BufferedCipherBase // TypeDefIndex: 4626
{
	// Fields
	private readonly IAeadBlockCipher cipher; // 0x10

	// Properties
	public override string AlgorithmName { get; }

	// Methods

	// RVA: 0x2464B38 Offset: 0x2464B38 VA: 0x2464B38
	public void .ctor(IAeadBlockCipher cipher) { }

	// RVA: 0x2464C04 Offset: 0x2464C04 VA: 0x2464C04 Slot: 22
	public override string get_AlgorithmName() { }

	// RVA: 0x2464CB8 Offset: 0x2464CB8 VA: 0x2464CB8 Slot: 23
	public override void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x2464DD4 Offset: 0x2464DD4 VA: 0x2464DD4 Slot: 24
	public override int GetBlockSize() { }

	// RVA: 0x2464E8C Offset: 0x2464E8C VA: 0x2464E8C Slot: 26
	public override int GetUpdateOutputSize(int length) { }

	// RVA: 0x2464F54 Offset: 0x2464F54 VA: 0x2464F54 Slot: 25
	public override int GetOutputSize(int length) { }

	// RVA: 0x246501C Offset: 0x246501C VA: 0x246501C Slot: 28
	public override int ProcessByte(byte input, byte[] output, int outOff) { }

	// RVA: 0x24650FC Offset: 0x24650FC VA: 0x24650FC Slot: 27
	public override byte[] ProcessByte(byte input) { }

	// RVA: 0x24651FC Offset: 0x24651FC VA: 0x24651FC Slot: 30
	public override byte[] ProcessBytes(byte[] input, int inOff, int length) { }

	// RVA: 0x246536C Offset: 0x246536C VA: 0x246536C Slot: 32
	public override int ProcessBytes(byte[] input, int inOff, int length, byte[] output, int outOff) { }

	// RVA: 0x2465464 Offset: 0x2465464 VA: 0x2465464 Slot: 33
	public override byte[] DoFinal() { }

	// RVA: 0x246554C Offset: 0x246554C VA: 0x246554C Slot: 35
	public override byte[] DoFinal(byte[] input, int inOff, int inLen) { }

	// RVA: 0x24656CC Offset: 0x24656CC VA: 0x24656CC Slot: 36
	public override int DoFinal(byte[] output, int outOff) { }

	// RVA: 0x246579C Offset: 0x246579C VA: 0x246579C Slot: 39
	public override void Reset() { }
}

// Namespace: Org.BouncyCastle.Crypto
public class BufferedAsymmetricBlockCipher : BufferedCipherBase // TypeDefIndex: 4627
{
	// Fields
	private readonly IAsymmetricBlockCipher cipher; // 0x10
	private byte[] buffer; // 0x18
	private int bufOff; // 0x20

	// Properties
	public override string AlgorithmName { get; }

	// Methods

	// RVA: 0x2465854 Offset: 0x2465854 VA: 0x2465854
	public void .ctor(IAsymmetricBlockCipher cipher) { }

	// RVA: 0x24658D0 Offset: 0x24658D0 VA: 0x24658D0
	internal int GetBufferPosition() { }

	// RVA: 0x24658D8 Offset: 0x24658D8 VA: 0x24658D8 Slot: 22
	public override string get_AlgorithmName() { }

	// RVA: 0x246598C Offset: 0x246598C VA: 0x246598C Slot: 24
	public override int GetBlockSize() { }

	// RVA: 0x2465A44 Offset: 0x2465A44 VA: 0x2465A44 Slot: 25
	public override int GetOutputSize(int length) { }

	// RVA: 0x2465AFC Offset: 0x2465AFC VA: 0x2465AFC Slot: 26
	public override int GetUpdateOutputSize(int length) { }

	// RVA: 0x2465B04 Offset: 0x2465B04 VA: 0x2465B04 Slot: 23
	public override void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x2465C9C Offset: 0x2465C9C VA: 0x2465C9C Slot: 27
	public override byte[] ProcessByte(byte input) { }

	// RVA: 0x2465D98 Offset: 0x2465D98 VA: 0x2465D98 Slot: 30
	public override byte[] ProcessBytes(byte[] input, int inOff, int length) { }

	// RVA: 0x2465EC0 Offset: 0x2465EC0 VA: 0x2465EC0 Slot: 33
	public override byte[] DoFinal() { }

	// RVA: 0x2465FE8 Offset: 0x2465FE8 VA: 0x2465FE8 Slot: 35
	public override byte[] DoFinal(byte[] input, int inOff, int length) { }

	// RVA: 0x2466024 Offset: 0x2466024 VA: 0x2466024 Slot: 39
	public override void Reset() { }
}

// Namespace: Org.BouncyCastle.Crypto
public class BufferedBlockCipher : BufferedCipherBase // TypeDefIndex: 4628
{
	// Fields
	internal byte[] buf; // 0x10
	internal int bufOff; // 0x18
	internal bool forEncryption; // 0x1C
	internal IBlockCipher cipher; // 0x20

	// Properties
	public override string AlgorithmName { get; }

	// Methods

	// RVA: 0x246605C Offset: 0x246605C VA: 0x246605C
	protected void .ctor() { }

	// RVA: 0x24660C4 Offset: 0x24660C4 VA: 0x24660C4
	public void .ctor(IBlockCipher cipher) { }

	// RVA: 0x2466214 Offset: 0x2466214 VA: 0x2466214 Slot: 22
	public override string get_AlgorithmName() { }

	// RVA: 0x24662C8 Offset: 0x24662C8 VA: 0x24662C8 Slot: 23
	public override void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x24663FC Offset: 0x24663FC VA: 0x24663FC Slot: 24
	public override int GetBlockSize() { }

	// RVA: 0x24664B4 Offset: 0x24664B4 VA: 0x24664B4 Slot: 26
	public override int GetUpdateOutputSize(int length) { }

	// RVA: 0x24664F0 Offset: 0x24664F0 VA: 0x24664F0 Slot: 25
	public override int GetOutputSize(int length) { }

	// RVA: 0x24664FC Offset: 0x24664FC VA: 0x24664FC Slot: 28
	public override int ProcessByte(byte input, byte[] output, int outOff) { }

	// RVA: 0x24666DC Offset: 0x24666DC VA: 0x24666DC Slot: 27
	public override byte[] ProcessByte(byte input) { }

	// RVA: 0x24667DC Offset: 0x24667DC VA: 0x24667DC Slot: 30
	public override byte[] ProcessBytes(byte[] input, int inOff, int length) { }

	// RVA: 0x246694C Offset: 0x246694C VA: 0x246694C Slot: 32
	public override int ProcessBytes(byte[] input, int inOff, int length, byte[] output, int outOff) { }

	// RVA: 0x2466DA8 Offset: 0x2466DA8 VA: 0x2466DA8 Slot: 33
	public override byte[] DoFinal() { }

	// RVA: 0x2466EDC Offset: 0x2466EDC VA: 0x2466EDC Slot: 35
	public override byte[] DoFinal(byte[] input, int inOff, int inLen) { }

	// RVA: 0x24670AC Offset: 0x24670AC VA: 0x24670AC Slot: 36
	public override int DoFinal(byte[] output, int outOff) { }

	// RVA: 0x2467374 Offset: 0x2467374 VA: 0x2467374 Slot: 39
	public override void Reset() { }
}

// Namespace: Org.BouncyCastle.Crypto
public abstract class BufferedCipherBase : IBufferedCipher // TypeDefIndex: 4629
{
	// Fields
	protected static readonly byte[] EmptyBuffer; // 0x0

	// Properties
	public abstract string AlgorithmName { get; }

	// Methods

	// RVA: 0x2464BFC Offset: 0x2464BFC VA: 0x2464BFC
	protected void .ctor() { }

	// RVA: -1 Offset: -1 Slot: 22
	public abstract string get_AlgorithmName();

	// RVA: -1 Offset: -1 Slot: 23
	public abstract void Init(bool forEncryption, ICipherParameters parameters);

	// RVA: -1 Offset: -1 Slot: 24
	public abstract int GetBlockSize();

	// RVA: -1 Offset: -1 Slot: 25
	public abstract int GetOutputSize(int inputLen);

	// RVA: -1 Offset: -1 Slot: 26
	public abstract int GetUpdateOutputSize(int inputLen);

	// RVA: -1 Offset: -1 Slot: 27
	public abstract byte[] ProcessByte(byte input);

	// RVA: 0x2467454 Offset: 0x2467454 VA: 0x2467454 Slot: 28
	public virtual int ProcessByte(byte input, byte[] output, int outOff) { }

	// RVA: 0x246754C Offset: 0x246754C VA: 0x246754C Slot: 29
	public virtual byte[] ProcessBytes(byte[] input) { }

	// RVA: -1 Offset: -1 Slot: 30
	public abstract byte[] ProcessBytes(byte[] input, int inOff, int length);

	// RVA: 0x2467594 Offset: 0x2467594 VA: 0x2467594 Slot: 31
	public virtual int ProcessBytes(byte[] input, byte[] output, int outOff) { }

	// RVA: 0x24675F4 Offset: 0x24675F4 VA: 0x24675F4 Slot: 32
	public virtual int ProcessBytes(byte[] input, int inOff, int length, byte[] output, int outOff) { }

	// RVA: -1 Offset: -1 Slot: 33
	public abstract byte[] DoFinal();

	// RVA: 0x2467704 Offset: 0x2467704 VA: 0x2467704 Slot: 34
	public virtual byte[] DoFinal(byte[] input) { }

	// RVA: -1 Offset: -1 Slot: 35
	public abstract byte[] DoFinal(byte[] input, int inOff, int length);

	// RVA: 0x246774C Offset: 0x246774C VA: 0x246774C Slot: 36
	public virtual int DoFinal(byte[] output, int outOff) { }

	// RVA: 0x2467840 Offset: 0x2467840 VA: 0x2467840 Slot: 37
	public virtual int DoFinal(byte[] input, byte[] output, int outOff) { }

	// RVA: 0x24678A0 Offset: 0x24678A0 VA: 0x24678A0 Slot: 38
	public virtual int DoFinal(byte[] input, int inOff, int length, byte[] output, int outOff) { }

	// RVA: -1 Offset: -1 Slot: 39
	public abstract void Reset();

	// RVA: 0x2467900 Offset: 0x2467900 VA: 0x2467900
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto
public class BufferedIesCipher : BufferedCipherBase // TypeDefIndex: 4630
{
	// Fields
	private readonly IesEngine engine; // 0x10
	private bool forEncryption; // 0x18
	private MemoryStream buffer; // 0x20

	// Properties
	public override string AlgorithmName { get; }

	// Methods

	// RVA: 0x2467964 Offset: 0x2467964 VA: 0x2467964
	public void .ctor(IesEngine engine) { }

	// RVA: 0x2467A48 Offset: 0x2467A48 VA: 0x2467A48 Slot: 22
	public override string get_AlgorithmName() { }

	// RVA: 0x2467A90 Offset: 0x2467A90 VA: 0x2467A90 Slot: 23
	public override void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x2467B20 Offset: 0x2467B20 VA: 0x2467B20 Slot: 24
	public override int GetBlockSize() { }

	// RVA: 0x2467B28 Offset: 0x2467B28 VA: 0x2467B28 Slot: 25
	public override int GetOutputSize(int inputLen) { }

	// RVA: 0x2467BF8 Offset: 0x2467BF8 VA: 0x2467BF8 Slot: 26
	public override int GetUpdateOutputSize(int inputLen) { }

	// RVA: 0x2467C00 Offset: 0x2467C00 VA: 0x2467C00 Slot: 27
	public override byte[] ProcessByte(byte input) { }

	// RVA: 0x2467C48 Offset: 0x2467C48 VA: 0x2467C48 Slot: 30
	public override byte[] ProcessBytes(byte[] input, int inOff, int length) { }

	// RVA: 0x2467D9C Offset: 0x2467D9C VA: 0x2467D9C Slot: 33
	public override byte[] DoFinal() { }

	// RVA: 0x2467E30 Offset: 0x2467E30 VA: 0x2467E30 Slot: 35
	public override byte[] DoFinal(byte[] input, int inOff, int length) { }

	// RVA: 0x2467E6C Offset: 0x2467E6C VA: 0x2467E6C Slot: 39
	public override void Reset() { }
}

// Namespace: Org.BouncyCastle.Crypto
public class BufferedStreamCipher : BufferedCipherBase // TypeDefIndex: 4631
{
	// Fields
	private readonly IStreamCipher cipher; // 0x10

	// Properties
	public override string AlgorithmName { get; }

	// Methods

	// RVA: 0x2467EA8 Offset: 0x2467EA8 VA: 0x2467EA8
	public void .ctor(IStreamCipher cipher) { }

	// RVA: 0x2467F6C Offset: 0x2467F6C VA: 0x2467F6C Slot: 22
	public override string get_AlgorithmName() { }

	// RVA: 0x2468020 Offset: 0x2468020 VA: 0x2468020 Slot: 23
	public override void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x246813C Offset: 0x246813C VA: 0x246813C Slot: 24
	public override int GetBlockSize() { }

	// RVA: 0x2468144 Offset: 0x2468144 VA: 0x2468144 Slot: 25
	public override int GetOutputSize(int inputLen) { }

	// RVA: 0x246814C Offset: 0x246814C VA: 0x246814C Slot: 26
	public override int GetUpdateOutputSize(int inputLen) { }

	// RVA: 0x2468154 Offset: 0x2468154 VA: 0x2468154 Slot: 27
	public override byte[] ProcessByte(byte input) { }

	// RVA: 0x2468268 Offset: 0x2468268 VA: 0x2468268 Slot: 28
	public override int ProcessByte(byte input, byte[] output, int outOff) { }

	// RVA: 0x24683DC Offset: 0x24683DC VA: 0x24683DC Slot: 30
	public override byte[] ProcessBytes(byte[] input, int inOff, int length) { }

	// RVA: 0x24684F4 Offset: 0x24684F4 VA: 0x24684F4 Slot: 32
	public override int ProcessBytes(byte[] input, int inOff, int length, byte[] output, int outOff) { }

	// RVA: 0x2468604 Offset: 0x2468604 VA: 0x2468604 Slot: 33
	public override byte[] DoFinal() { }

	// RVA: 0x2468684 Offset: 0x2468684 VA: 0x2468684 Slot: 35
	public override byte[] DoFinal(byte[] input, int inOff, int length) { }

	// RVA: 0x2468754 Offset: 0x2468754 VA: 0x2468754 Slot: 39
	public override void Reset() { }
}

// Namespace: Org.BouncyCastle.Crypto
internal class Check // TypeDefIndex: 4632
{
	// Methods

	// RVA: 0x246880C Offset: 0x246880C VA: 0x246880C
	public void .ctor() { }

	// RVA: 0x24672E8 Offset: 0x24672E8 VA: 0x24672E8
	internal static void DataLength(bool condition, string msg) { }

	// RVA: 0x2468814 Offset: 0x2468814 VA: 0x2468814
	internal static void DataLength(byte[] buf, int off, int len, string msg) { }

	// RVA: 0x2466CF4 Offset: 0x2466CF4 VA: 0x2466CF4
	internal static void OutputLength(byte[] buf, int off, int len, string msg) { }
}

// Namespace: Org.BouncyCastle.Crypto
public class CipherKeyGenerator // TypeDefIndex: 4633
{
	// Fields
	protected internal SecureRandom random; // 0x10
	protected internal int strength; // 0x18
	private bool uninitialised; // 0x1C
	private int defaultStrength; // 0x20

	// Properties
	public int DefaultStrength { get; }

	// Methods

	// RVA: 0x24688C8 Offset: 0x24688C8 VA: 0x24688C8
	public void .ctor() { }

	// RVA: 0x24688D8 Offset: 0x24688D8 VA: 0x24688D8
	internal void .ctor(int defaultStrength) { }

	// RVA: 0x2468994 Offset: 0x2468994 VA: 0x2468994
	public int get_DefaultStrength() { }

	// RVA: 0x246899C Offset: 0x246899C VA: 0x246899C
	public void Init(KeyGenerationParameters parameters) { }

	// RVA: 0x2468A44 Offset: 0x2468A44 VA: 0x2468A44 Slot: 4
	protected virtual void engineInit(KeyGenerationParameters parameters) { }

	// RVA: 0x2468AC0 Offset: 0x2468AC0 VA: 0x2468AC0
	public byte[] GenerateKey() { }

	// RVA: 0x2468BC8 Offset: 0x2468BC8 VA: 0x2468BC8 Slot: 5
	protected virtual byte[] engineGenerateKey() { }
}

// Namespace: Org.BouncyCastle.Crypto
[Serializable]
public class CryptoException : Exception // TypeDefIndex: 4634
{
	// Methods

	// RVA: 0x2468C3C Offset: 0x2468C3C VA: 0x2468C3C
	public void .ctor() { }

	// RVA: 0x2468C44 Offset: 0x2468C44 VA: 0x2468C44
	public void .ctor(string message) { }

	// RVA: 0x2468C4C Offset: 0x2468C4C VA: 0x2468C4C
	public void .ctor(string message, Exception exception) { }
}

// Namespace: Org.BouncyCastle.Crypto
[Serializable]
public class DataLengthException : CryptoException // TypeDefIndex: 4635
{
	// Methods

	// RVA: 0x2468C54 Offset: 0x2468C54 VA: 0x2468C54
	public void .ctor() { }

	// RVA: 0x2465D90 Offset: 0x2465D90 VA: 0x2465D90
	public void .ctor(string message) { }

	// RVA: 0x2468C5C Offset: 0x2468C5C VA: 0x2468C5C
	public void .ctor(string message, Exception exception) { }
}

// Namespace: Org.BouncyCastle.Crypto.Digests
public abstract class GeneralDigest : IDigest, IMemoable // TypeDefIndex: 4636
{
	// Fields
	private const int BYTE_LENGTH = 64;
	private byte[] xBuf; // 0x10
	private int xBufOff; // 0x18
	private long byteCount; // 0x20

	// Properties
	public abstract string AlgorithmName { get; }

	// Methods

	// RVA: 0x2468C64 Offset: 0x2468C64 VA: 0x2468C64
	internal void .ctor() { }

	// RVA: 0x2468CC8 Offset: 0x2468CC8 VA: 0x2468CC8
	internal void .ctor(GeneralDigest t) { }

	// RVA: 0x2468D5C Offset: 0x2468D5C VA: 0x2468D5C
	protected void CopyIn(GeneralDigest t) { }

	// RVA: 0x2468E20 Offset: 0x2468E20 VA: 0x2468E20 Slot: 7
	public void Update(byte input) { }

	// RVA: 0x2468ED4 Offset: 0x2468ED4 VA: 0x2468ED4 Slot: 8
	public void BlockUpdate(byte[] input, int inOff, int length) { }

	// RVA: 0x24690D8 Offset: 0x24690D8 VA: 0x24690D8
	public void Finish() { }

	// RVA: 0x2469140 Offset: 0x2469140 VA: 0x2469140 Slot: 13
	public virtual void Reset() { }

	// RVA: 0x2469180 Offset: 0x2469180 VA: 0x2469180 Slot: 6
	public int GetByteLength() { }

	// RVA: -1 Offset: -1 Slot: 14
	internal abstract void ProcessWord(byte[] input, int inOff);

	// RVA: -1 Offset: -1 Slot: 15
	internal abstract void ProcessLength(long bitLength);

	// RVA: -1 Offset: -1 Slot: 16
	internal abstract void ProcessBlock();

	// RVA: -1 Offset: -1 Slot: 17
	public abstract string get_AlgorithmName();

	// RVA: -1 Offset: -1 Slot: 18
	public abstract int GetDigestSize();

	// RVA: -1 Offset: -1 Slot: 19
	public abstract int DoFinal(byte[] output, int outOff);

	// RVA: -1 Offset: -1 Slot: 20
	public abstract IMemoable Copy();

	// RVA: -1 Offset: -1 Slot: 21
	public abstract void Reset(IMemoable t);
}

// Namespace: Org.BouncyCastle.Crypto.Digests
public class Gost3411Digest : IDigest, IMemoable // TypeDefIndex: 4637
{
	// Fields
	private const int DIGEST_LENGTH = 32;
	private byte[] H; // 0x10
	private byte[] L; // 0x18
	private byte[] M; // 0x20
	private byte[] Sum; // 0x28
	private byte[][] C; // 0x30
	private byte[] xBuf; // 0x38
	private int xBufOff; // 0x40
	private ulong byteCount; // 0x48
	private readonly IBlockCipher cipher; // 0x50
	private byte[] sBox; // 0x58
	private byte[] K; // 0x60
	private byte[] a; // 0x68
	internal short[] wS; // 0x70
	internal short[] w_S; // 0x78
	internal byte[] S; // 0x80
	internal byte[] U; // 0x88
	internal byte[] V; // 0x90
	internal byte[] W; // 0x98
	private static readonly byte[] C2; // 0x0

	// Properties
	public string AlgorithmName { get; }

	// Methods

	// RVA: 0x2469188 Offset: 0x2469188 VA: 0x2469188
	public void .ctor() { }

	// RVA: 0x2469750 Offset: 0x2469750 VA: 0x2469750
	public void .ctor(byte[] sBoxParam) { }

	// RVA: 0x2469990 Offset: 0x2469990 VA: 0x2469990
	public void .ctor(Gost3411Digest t) { }

	// RVA: 0x24693E4 Offset: 0x24693E4 VA: 0x24693E4
	private static byte[][] MakeC() { }

	// RVA: 0x246A0B4 Offset: 0x246A0B4 VA: 0x246A0B4 Slot: 4
	public string get_AlgorithmName() { }

	// RVA: 0x246A0FC Offset: 0x246A0FC VA: 0x246A0FC Slot: 5
	public int GetDigestSize() { }

	// RVA: 0x246A104 Offset: 0x246A104 VA: 0x246A104 Slot: 7
	public void Update(byte input) { }

	// RVA: 0x246A7DC Offset: 0x246A7DC VA: 0x246A7DC Slot: 8
	public void BlockUpdate(byte[] input, int inOff, int length) { }

	// RVA: 0x246A9AC Offset: 0x246A9AC VA: 0x246A9AC
	private byte[] P(byte[] input) { }

	// RVA: 0x246AB90 Offset: 0x246AB90 VA: 0x246AB90
	private byte[] A(byte[] input) { }

	// RVA: 0x246ACA4 Offset: 0x246ACA4 VA: 0x246ACA4
	private void E(byte[] key, byte[] s, int sOff, byte[] input, int inOff) { }

	// RVA: 0x246AE34 Offset: 0x246AE34 VA: 0x246AE34
	private void fw(byte[] input) { }

	// RVA: 0x246A2C4 Offset: 0x246A2C4 VA: 0x246A2C4
	private void processBlock(byte[] input, int inOff) { }

	// RVA: 0x246B250 Offset: 0x246B250 VA: 0x246B250
	private void finish() { }

	// RVA: 0x246B2B4 Offset: 0x246B2B4 VA: 0x246B2B4 Slot: 9
	public int DoFinal(byte[] output, int outOff) { }

	// RVA: 0x24694D4 Offset: 0x24694D4 VA: 0x24694D4 Slot: 10
	public void Reset() { }

	// RVA: 0x246A1B8 Offset: 0x246A1B8 VA: 0x246A1B8
	private void sumByteArray(byte[] input) { }

	// RVA: 0x246B044 Offset: 0x246B044 VA: 0x246B044
	private static void cpyBytesToShort(byte[] S, short[] wS) { }

	// RVA: 0x246B138 Offset: 0x246B138 VA: 0x246B138
	private static void cpyShortToBytes(short[] wS, byte[] S) { }

	// RVA: 0x246B314 Offset: 0x246B314 VA: 0x246B314 Slot: 6
	public int GetByteLength() { }

	// RVA: 0x246B31C Offset: 0x246B31C VA: 0x246B31C Slot: 11
	public IMemoable Copy() { }

	// RVA: 0x2469B18 Offset: 0x2469B18 VA: 0x2469B18 Slot: 12
	public void Reset(IMemoable other) { }

	// RVA: 0x246B37C Offset: 0x246B37C VA: 0x246B37C
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Digests
public class KeccakDigest : IDigest, IMemoable // TypeDefIndex: 4638
{
	// Fields
	private static readonly ulong[] KeccakRoundConstants; // 0x0
	private static readonly int[] KeccakRhoOffsets; // 0x8
	protected byte[] state; // 0x10
	protected byte[] dataQueue; // 0x18
	protected int rate; // 0x20
	protected int bitsInQueue; // 0x24
	protected int fixedOutputLength; // 0x28
	protected bool squeezing; // 0x2C
	protected int bitsAvailableForSqueezing; // 0x30
	protected byte[] chunk; // 0x38
	protected byte[] oneByte; // 0x40
	private ulong[] C; // 0x48
	private ulong[] tempA; // 0x50
	private ulong[] chiC; // 0x58

	// Properties
	public virtual string AlgorithmName { get; }

	// Methods

	// RVA: 0x246B3F8 Offset: 0x246B3F8 VA: 0x246B3F8
	public void .ctor() { }

	// RVA: 0x246B400 Offset: 0x246B400 VA: 0x246B400
	public void .ctor(int bitLength) { }

	// RVA: 0x246B5C8 Offset: 0x246B5C8 VA: 0x246B5C8
	public void .ctor(KeccakDigest source) { }

	// RVA: 0x246B840 Offset: 0x246B840 VA: 0x246B840
	private static ulong[] KeccakInitializeRoundConstants() { }

	// RVA: 0x246B964 Offset: 0x246B964 VA: 0x246B964
	private static int[] KeccakInitializeRhoOffsets() { }

	// RVA: 0x246BAA8 Offset: 0x246BAA8 VA: 0x246BAA8
	private void ClearDataQueueSection(int off, int len) { }

	// RVA: 0x246B688 Offset: 0x246B688 VA: 0x246B688
	private void CopyIn(KeccakDigest source) { }

	// RVA: 0x246BB24 Offset: 0x246BB24 VA: 0x246BB24 Slot: 13
	public virtual string get_AlgorithmName() { }

	// RVA: 0x246BBC8 Offset: 0x246BBC8 VA: 0x246BBC8 Slot: 14
	public virtual int GetDigestSize() { }

	// RVA: 0x246BBE0 Offset: 0x246BBE0 VA: 0x246BBE0 Slot: 15
	public virtual void Update(byte input) { }

	// RVA: 0x246BC50 Offset: 0x246BC50 VA: 0x246BC50 Slot: 16
	public virtual void BlockUpdate(byte[] input, int inOff, int len) { }

	// RVA: 0x246BC64 Offset: 0x246BC64 VA: 0x246BC64 Slot: 17
	public virtual int DoFinal(byte[] output, int outOff) { }

	// RVA: 0x246BCB8 Offset: 0x246BCB8 VA: 0x246BCB8 Slot: 18
	protected virtual int DoFinal(byte[] output, int outOff, byte partialByte, int partialBits) { }

	// RVA: 0x246BD8C Offset: 0x246BD8C VA: 0x246BD8C Slot: 19
	public virtual void Reset() { }

	// RVA: 0x246BD94 Offset: 0x246BD94 VA: 0x246BD94 Slot: 20
	public virtual int GetByteLength() { }

	// RVA: 0x246B4C0 Offset: 0x246B4C0 VA: 0x246B4C0
	private void Init(int bitLength) { }

	// RVA: 0x246BDAC Offset: 0x246BDAC VA: 0x246BDAC
	private void InitSponge(int rate, int capacity) { }

	// RVA: 0x246BEE4 Offset: 0x246BEE4 VA: 0x246BEE4
	private void AbsorbQueue() { }

	// RVA: 0x246BF24 Offset: 0x246BF24 VA: 0x246BF24 Slot: 21
	protected virtual void Absorb(byte[] data, int off, long databitlen) { }

	// RVA: 0x246C258 Offset: 0x246C258 VA: 0x246C258
	private void PadAndSwitchToSqueezingPhase() { }

	// RVA: 0x246C524 Offset: 0x246C524 VA: 0x246C524 Slot: 22
	protected virtual void Squeeze(byte[] output, int offset, long outputLength) { }

	// RVA: 0x246C788 Offset: 0x246C788 VA: 0x246C788
	private static void FromBytesToWords(ulong[] stateAsWords, byte[] state) { }

	// RVA: 0x246C880 Offset: 0x246C880 VA: 0x246C880
	private static void FromWordsToBytes(byte[] state, ulong[] stateAsWords) { }

	// RVA: 0x246C6C4 Offset: 0x246C6C4 VA: 0x246C6C4
	private void KeccakPermutation(byte[] state) { }

	// RVA: 0x246CA04 Offset: 0x246CA04 VA: 0x246CA04
	private void KeccakPermutationAfterXor(byte[] state, byte[] data, int dataLengthInBytes) { }

	// RVA: 0x246C950 Offset: 0x246C950 VA: 0x246C950
	private void KeccakPermutationOnWords(ulong[] state) { }

	// RVA: 0x246CACC Offset: 0x246CACC VA: 0x246CACC
	private void Theta(ulong[] A) { }

	// RVA: 0x246CD04 Offset: 0x246CD04 VA: 0x246CD04
	private void Rho(ulong[] A) { }

	// RVA: 0x246CF20 Offset: 0x246CF20 VA: 0x246CF20
	private void Pi(ulong[] A) { }

	// RVA: 0x246D06C Offset: 0x246D06C VA: 0x246D06C
	private void Chi(ulong[] A) { }

	// RVA: 0x246D26C Offset: 0x246D26C VA: 0x246D26C
	private static void Iota(ulong[] A, int indexRound) { }

	// RVA: 0x246BF20 Offset: 0x246BF20 VA: 0x246BF20
	private void KeccakAbsorb(byte[] byteState, byte[] data, int dataInBytes) { }

	// RVA: 0x246C4F4 Offset: 0x246C4F4 VA: 0x246C4F4
	private void KeccakExtract1024bits(byte[] byteState, byte[] data) { }

	// RVA: 0x246C50C Offset: 0x246C50C VA: 0x246C50C
	private void KeccakExtract(byte[] byteState, byte[] data, int laneCount) { }

	// RVA: 0x246D348 Offset: 0x246D348 VA: 0x246D348 Slot: 23
	public virtual IMemoable Copy() { }

	// RVA: 0x246D3A8 Offset: 0x246D3A8 VA: 0x246D3A8 Slot: 24
	public virtual void Reset(IMemoable other) { }

	// RVA: 0x246D480 Offset: 0x246D480 VA: 0x246D480
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Digests
public abstract class LongDigest : IDigest, IMemoable // TypeDefIndex: 4639
{
	// Fields
	private int MyByteLength; // 0x10
	private byte[] xBuf; // 0x18
	private int xBufOff; // 0x20
	private long byteCount1; // 0x28
	private long byteCount2; // 0x30
	internal ulong H1; // 0x38
	internal ulong H2; // 0x40
	internal ulong H3; // 0x48
	internal ulong H4; // 0x50
	internal ulong H5; // 0x58
	internal ulong H6; // 0x60
	internal ulong H7; // 0x68
	internal ulong H8; // 0x70
	private ulong[] W; // 0x78
	private int wOff; // 0x80
	internal static readonly ulong[] K; // 0x0

	// Properties
	public abstract string AlgorithmName { get; }

	// Methods

	// RVA: 0x246D4E4 Offset: 0x246D4E4 VA: 0x246D4E4
	internal void .ctor() { }

	// RVA: 0x246D574 Offset: 0x246D574 VA: 0x246D574
	internal void .ctor(LongDigest t) { }

	// RVA: 0x246D628 Offset: 0x246D628 VA: 0x246D628
	protected void CopyIn(LongDigest t) { }

	// RVA: 0x246D860 Offset: 0x246D860 VA: 0x246D860 Slot: 7
	public void Update(byte input) { }

	// RVA: 0x246D9A0 Offset: 0x246D9A0 VA: 0x246D9A0 Slot: 8
	public void BlockUpdate(byte[] input, int inOff, int length) { }

	// RVA: 0x246DB38 Offset: 0x246DB38 VA: 0x246DB38
	public void Finish() { }

	// RVA: 0x246E708 Offset: 0x246E708 VA: 0x246E708 Slot: 13
	public virtual void Reset() { }

	// RVA: 0x246D908 Offset: 0x246D908 VA: 0x246D908
	internal void ProcessWord(byte[] input, int inOff) { }

	// RVA: 0x246DBB0 Offset: 0x246DBB0 VA: 0x246DBB0
	private void AdjustByteCounts() { }

	// RVA: 0x246DBD4 Offset: 0x246DBD4 VA: 0x246DBD4
	internal void ProcessLength(long lowW, long hiW) { }

	// RVA: 0x246DC74 Offset: 0x246DC74 VA: 0x246DC74
	internal void ProcessBlock() { }

	// RVA: 0x246E7E8 Offset: 0x246E7E8 VA: 0x246E7E8
	private static ulong Ch(ulong x, ulong y, ulong z) { }

	// RVA: 0x246E808 Offset: 0x246E808 VA: 0x246E808
	private static ulong Maj(ulong x, ulong y, ulong z) { }

	// RVA: 0x246E7F8 Offset: 0x246E7F8 VA: 0x246E7F8
	private static ulong Sum0(ulong x) { }

	// RVA: 0x246E7D8 Offset: 0x246E7D8 VA: 0x246E7D8
	private static ulong Sum1(ulong x) { }

	// RVA: 0x246E7C8 Offset: 0x246E7C8 VA: 0x246E7C8
	private static ulong Sigma0(ulong x) { }

	// RVA: 0x246E7B8 Offset: 0x246E7B8 VA: 0x246E7B8
	private static ulong Sigma1(ulong x) { }

	// RVA: 0x246E81C Offset: 0x246E81C VA: 0x246E81C Slot: 6
	public int GetByteLength() { }

	// RVA: -1 Offset: -1 Slot: 14
	public abstract string get_AlgorithmName();

	// RVA: -1 Offset: -1 Slot: 15
	public abstract int GetDigestSize();

	// RVA: -1 Offset: -1 Slot: 16
	public abstract int DoFinal(byte[] output, int outOff);

	// RVA: -1 Offset: -1 Slot: 17
	public abstract IMemoable Copy();

	// RVA: -1 Offset: -1 Slot: 18
	public abstract void Reset(IMemoable t);

	// RVA: 0x246E824 Offset: 0x246E824 VA: 0x246E824
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Digests
public class MD2Digest : IDigest, IMemoable // TypeDefIndex: 4640
{
	// Fields
	private const int DigestLength = 16;
	private const int BYTE_LENGTH = 16;
	private byte[] X; // 0x10
	private int xOff; // 0x18
	private byte[] M; // 0x20
	private int mOff; // 0x28
	private byte[] C; // 0x30
	private int COff; // 0x38
	private static readonly byte[] S; // 0x0

	// Properties
	public string AlgorithmName { get; }

	// Methods

	// RVA: 0x246E8A0 Offset: 0x246E8A0 VA: 0x246E8A0
	public void .ctor() { }

	// RVA: 0x246EA78 Offset: 0x246EA78 VA: 0x246EA78
	public void .ctor(MD2Digest t) { }

	// RVA: 0x246EB10 Offset: 0x246EB10 VA: 0x246EB10
	private void CopyIn(MD2Digest t) { }

	// RVA: 0x246ECAC Offset: 0x246ECAC VA: 0x246ECAC Slot: 4
	public string get_AlgorithmName() { }

	// RVA: 0x246ECF4 Offset: 0x246ECF4 VA: 0x246ECF4 Slot: 5
	public int GetDigestSize() { }

	// RVA: 0x246ECFC Offset: 0x246ECFC VA: 0x246ECFC Slot: 6
	public int GetByteLength() { }

	// RVA: 0x246ED04 Offset: 0x246ED04 VA: 0x246ED04 Slot: 9
	public int DoFinal(byte[] output, int outOff) { }

	// RVA: 0x246E928 Offset: 0x246E928 VA: 0x246E928 Slot: 10
	public void Reset() { }

	// RVA: 0x246F1F4 Offset: 0x246F1F4 VA: 0x246F1F4 Slot: 7
	public void Update(byte input) { }

	// RVA: 0x246F284 Offset: 0x246F284 VA: 0x246F284 Slot: 8
	public void BlockUpdate(byte[] input, int inOff, int length) { }

	// RVA: 0x246EE08 Offset: 0x246EE08 VA: 0x246EE08
	internal void ProcessChecksum(byte[] m) { }

	// RVA: 0x246EFA4 Offset: 0x246EFA4 VA: 0x246EFA4
	internal void ProcessBlock(byte[] m) { }

	// RVA: 0x246F3F0 Offset: 0x246F3F0 VA: 0x246F3F0 Slot: 11
	public IMemoable Copy() { }

	// RVA: 0x246F450 Offset: 0x246F450 VA: 0x246F450 Slot: 12
	public void Reset(IMemoable other) { }

	// RVA: 0x246F528 Offset: 0x246F528 VA: 0x246F528
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Digests
public class MD4Digest : GeneralDigest // TypeDefIndex: 4641
{
	// Fields
	private const int DigestLength = 16;
	private int H1; // 0x28
	private int H2; // 0x2C
	private int H3; // 0x30
	private int H4; // 0x34
	private int[] X; // 0x38
	private int xOff; // 0x40
	private const int S11 = 3;
	private const int S12 = 7;
	private const int S13 = 11;
	private const int S14 = 19;
	private const int S21 = 3;
	private const int S22 = 5;
	private const int S23 = 9;
	private const int S24 = 13;
	private const int S31 = 3;
	private const int S32 = 9;
	private const int S33 = 11;
	private const int S34 = 15;

	// Properties
	public override string AlgorithmName { get; }

	// Methods

	// RVA: 0x246F5A4 Offset: 0x246F5A4 VA: 0x246F5A4
	public void .ctor() { }

	// RVA: 0x246F610 Offset: 0x246F610 VA: 0x246F610
	public void .ctor(MD4Digest t) { }

	// RVA: 0x246F688 Offset: 0x246F688 VA: 0x246F688
	private void CopyIn(MD4Digest t) { }

	// RVA: 0x246F7A0 Offset: 0x246F7A0 VA: 0x246F7A0 Slot: 17
	public override string get_AlgorithmName() { }

	// RVA: 0x246F7E8 Offset: 0x246F7E8 VA: 0x246F7E8 Slot: 18
	public override int GetDigestSize() { }

	// RVA: 0x246F7F0 Offset: 0x246F7F0 VA: 0x246F7F0 Slot: 14
	internal override void ProcessWord(byte[] input, int inOff) { }

	// RVA: 0x246F964 Offset: 0x246F964 VA: 0x246F964 Slot: 15
	internal override void ProcessLength(long bitLength) { }

	// RVA: 0x246FA10 Offset: 0x246FA10 VA: 0x246FA10
	private void UnpackWord(int word, byte[] outBytes, int outOff) { }

	// RVA: 0x246FB00 Offset: 0x246FB00 VA: 0x246FB00 Slot: 19
	public override int DoFinal(byte[] output, int outOff) { }

	// RVA: 0x246FB84 Offset: 0x246FB84 VA: 0x246FB84 Slot: 13
	public override void Reset() { }

	// RVA: 0x246FC1C Offset: 0x246FC1C VA: 0x246FC1C
	private int RotateLeft(int x, int n) { }

	// RVA: 0x246FC2C Offset: 0x246FC2C VA: 0x246FC2C
	private int F(int u, int v, int w) { }

	// RVA: 0x246FC3C Offset: 0x246FC3C VA: 0x246FC3C
	private int G(int u, int v, int w) { }

	// RVA: 0x246FC50 Offset: 0x246FC50 VA: 0x246FC50
	private int H(int u, int v, int w) { }

	// RVA: 0x246FC5C Offset: 0x246FC5C VA: 0x246FC5C Slot: 16
	internal override void ProcessBlock() { }

	// RVA: 0x2470B2C Offset: 0x2470B2C VA: 0x2470B2C Slot: 20
	public override IMemoable Copy() { }

	// RVA: 0x2470B8C Offset: 0x2470B8C VA: 0x2470B8C Slot: 21
	public override void Reset(IMemoable other) { }
}

// Namespace: Org.BouncyCastle.Crypto.Digests
public class MD5Digest : GeneralDigest // TypeDefIndex: 4642
{
	// Fields
	private const int DigestLength = 16;
	private uint H1; // 0x28
	private uint H2; // 0x2C
	private uint H3; // 0x30
	private uint H4; // 0x34
	private uint[] X; // 0x38
	private int xOff; // 0x40
	private static readonly int S11; // 0x0
	private static readonly int S12; // 0x4
	private static readonly int S13; // 0x8
	private static readonly int S14; // 0xC
	private static readonly int S21; // 0x10
	private static readonly int S22; // 0x14
	private static readonly int S23; // 0x18
	private static readonly int S24; // 0x1C
	private static readonly int S31; // 0x20
	private static readonly int S32; // 0x24
	private static readonly int S33; // 0x28
	private static readonly int S34; // 0x2C
	private static readonly int S41; // 0x30
	private static readonly int S42; // 0x34
	private static readonly int S43; // 0x38
	private static readonly int S44; // 0x3C

	// Properties
	public override string AlgorithmName { get; }

	// Methods

	// RVA: 0x2470C64 Offset: 0x2470C64 VA: 0x2470C64
