	public virtual bool get_IsPartialBlockOkay() { }

	// RVA: 0x23E8FD0 Offset: 0x23E8FD0 VA: 0x23E8FD0 Slot: 13
	public virtual int GetBlockSize() { }

	// RVA: 0x23E8FD8 Offset: 0x23E8FD8 VA: 0x23E8FD8 Slot: 14
	public virtual int ProcessBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x23EC0A8 Offset: 0x23EC0A8 VA: 0x23EC0A8 Slot: 15
	public virtual void Reset() { }

	// RVA: 0x23E9104 Offset: 0x23E9104 VA: 0x23E9104
	private void UnPackBlock(byte[] bytes, int off) { }

	// RVA: 0x23EC038 Offset: 0x23EC038 VA: 0x23EC038
	private void PackBlock(byte[] bytes, int off) { }

	// RVA: 0x23E9180 Offset: 0x23E9180 VA: 0x23E9180
	private void EncryptBlock(uint[][] KW) { }

	// RVA: 0x23EA908 Offset: 0x23EA908 VA: 0x23EA908
	private void DecryptBlock(uint[][] KW) { }

	// RVA: 0x23EC0AC Offset: 0x23EC0AC VA: 0x23EC0AC
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class AesWrapEngine : Rfc3394WrapEngine // TypeDefIndex: 4695
{
	// Methods

	// RVA: 0x2576F20 Offset: 0x2576F20 VA: 0x2576F20
	public void .ctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public sealed class BlowfishEngine : IBlockCipher // TypeDefIndex: 4696
{
	// Fields
	private static readonly uint[] KP; // 0x0
	private static readonly uint[] KS0; // 0x8
	private static readonly uint[] KS1; // 0x10
	private static readonly uint[] KS2; // 0x18
	private static readonly uint[] KS3; // 0x20
	private static readonly int ROUNDS; // 0x28
	private const int BLOCK_SIZE = 8;
	private static readonly int SBOX_SK; // 0x2C
	private static readonly int P_SZ; // 0x30
	private readonly uint[] S0; // 0x10
	private readonly uint[] S1; // 0x18
	private readonly uint[] S2; // 0x20
	private readonly uint[] S3; // 0x28
	private readonly uint[] P; // 0x30
	private bool encrypting; // 0x38
	private byte[] workingKey; // 0x40

	// Properties
	public string AlgorithmName { get; }
	public bool IsPartialBlockOkay { get; }

	// Methods

	// RVA: 0x2576F88 Offset: 0x2576F88 VA: 0x2576F88
	public void .ctor() { }

	// RVA: 0x257707C Offset: 0x257707C VA: 0x257707C Slot: 5
	public void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x2577780 Offset: 0x2577780 VA: 0x2577780 Slot: 4
	public string get_AlgorithmName() { }

	// RVA: 0x25777C8 Offset: 0x25777C8 VA: 0x25777C8 Slot: 7
	public bool get_IsPartialBlockOkay() { }

	// RVA: 0x25777D0 Offset: 0x25777D0 VA: 0x25777D0 Slot: 8
	public int ProcessBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x2577D58 Offset: 0x2577D58 VA: 0x2577D58 Slot: 9
	public void Reset() { }

	// RVA: 0x2577D5C Offset: 0x2577D5C VA: 0x2577D5C Slot: 6
	public int GetBlockSize() { }

	// RVA: 0x2577D64 Offset: 0x2577D64 VA: 0x2577D64
	private uint F(uint x) { }

	// RVA: 0x2577E80 Offset: 0x2577E80 VA: 0x2577E80
	private void ProcessTable(uint xl, uint xr, uint[] table) { }

	// RVA: 0x25772C8 Offset: 0x25772C8 VA: 0x25772C8
	private void SetKey(byte[] key) { }

	// RVA: 0x25778FC Offset: 0x25778FC VA: 0x25778FC
	private void EncryptBlock(byte[] src, int srcIndex, byte[] dst, int dstIndex) { }

	// RVA: 0x2577B40 Offset: 0x2577B40 VA: 0x2577B40
	private void DecryptBlock(byte[] src, int srcIndex, byte[] dst, int dstIndex) { }

	// RVA: 0x2578140 Offset: 0x2578140 VA: 0x2578140
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class CamelliaEngine : IBlockCipher // TypeDefIndex: 4697
{
	// Fields
	private bool initialised; // 0x10
	private bool _keyIs128; // 0x11
	private const int BLOCK_SIZE = 16;
	private uint[] subkey; // 0x18
	private uint[] kw; // 0x20
	private uint[] ke; // 0x28
	private uint[] state; // 0x30
	private static readonly uint[] SIGMA; // 0x0
	private static readonly uint[] SBOX1_1110; // 0x8
	private static readonly uint[] SBOX4_4404; // 0x10
	private static readonly uint[] SBOX2_0222; // 0x18
	private static readonly uint[] SBOX3_3033; // 0x20

	// Properties
	public virtual string AlgorithmName { get; }
	public virtual bool IsPartialBlockOkay { get; }

	// Methods

	// RVA: 0x25782AC Offset: 0x25782AC VA: 0x25782AC
	public void .ctor() { }

	// RVA: 0x257833C Offset: 0x257833C VA: 0x257833C
	private static uint rightRotate(uint x, int s) { }

	// RVA: 0x2578358 Offset: 0x2578358 VA: 0x2578358
	private static uint leftRotate(uint x, int s) { }

	// RVA: 0x2578374 Offset: 0x2578374 VA: 0x2578374
	private static void roldq(int rot, uint[] ki, int ioff, uint[] ko, int ooff) { }

	// RVA: 0x2578750 Offset: 0x2578750 VA: 0x2578750
	private static void decroldq(int rot, uint[] ki, int ioff, uint[] ko, int ooff) { }

	// RVA: 0x2578B38 Offset: 0x2578B38 VA: 0x2578B38
	private static void roldqo32(int rot, uint[] ki, int ioff, uint[] ko, int ooff) { }

	// RVA: 0x2578F0C Offset: 0x2578F0C VA: 0x2578F0C
	private static void decroldqo32(int rot, uint[] ki, int ioff, uint[] ko, int ooff) { }

	// RVA: 0x25792FC Offset: 0x25792FC VA: 0x25792FC
	private static uint bytes2uint(byte[] src, int offset) { }

	// RVA: 0x2579384 Offset: 0x2579384 VA: 0x2579384
	private static void uint2bytes(uint word, byte[] dst, int offset) { }

	// RVA: 0x2579404 Offset: 0x2579404 VA: 0x2579404
	private static void camelliaF2(uint[] s, uint[] skey, int keyoff) { }

	// RVA: 0x2579AE4 Offset: 0x2579AE4 VA: 0x2579AE4
	private static void camelliaFLs(uint[] s, uint[] fkey, int keyoff) { }

	// RVA: 0x2579D48 Offset: 0x2579D48 VA: 0x2579D48
	private void setKey(bool forEncryption, byte[] key) { }

	// RVA: 0x257BA20 Offset: 0x257BA20 VA: 0x257BA20
	private int processBlock128(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x257BED0 Offset: 0x257BED0 VA: 0x257BED0
	private int processBlock192or256(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x257C3BC Offset: 0x257C3BC VA: 0x257C3BC Slot: 10
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x257C4AC Offset: 0x257C4AC VA: 0x257C4AC Slot: 11
	public virtual string get_AlgorithmName() { }

	// RVA: 0x257C4F4 Offset: 0x257C4F4 VA: 0x257C4F4 Slot: 12
	public virtual bool get_IsPartialBlockOkay() { }

	// RVA: 0x257C4FC Offset: 0x257C4FC VA: 0x257C4FC Slot: 13
	public virtual int GetBlockSize() { }

	// RVA: 0x257C504 Offset: 0x257C504 VA: 0x257C504 Slot: 14
	public virtual int ProcessBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x257C630 Offset: 0x257C630 VA: 0x257C630 Slot: 15
	public virtual void Reset() { }

	// RVA: 0x257C634 Offset: 0x257C634 VA: 0x257C634
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class CamelliaWrapEngine : Rfc3394WrapEngine // TypeDefIndex: 4698
{
	// Methods

	// RVA: 0x257C778 Offset: 0x257C778 VA: 0x257C778
	public void .ctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class Cast5Engine : IBlockCipher // TypeDefIndex: 4699
{
	// Fields
	internal static readonly uint[] S1; // 0x0
	internal static readonly uint[] S2; // 0x8
	internal static readonly uint[] S3; // 0x10
	internal static readonly uint[] S4; // 0x18
	internal static readonly uint[] S5; // 0x20
	internal static readonly uint[] S6; // 0x28
	internal static readonly uint[] S7; // 0x30
	internal static readonly uint[] S8; // 0x38
	internal static readonly int MAX_ROUNDS; // 0x40
	internal static readonly int RED_ROUNDS; // 0x44
	private const int BLOCK_SIZE = 8;
	private int[] _Kr; // 0x10
	private uint[] _Km; // 0x18
	private bool _encrypting; // 0x20
	private byte[] _workingKey; // 0x28
	private int _rounds; // 0x30

	// Properties
	public virtual string AlgorithmName { get; }
	public virtual bool IsPartialBlockOkay { get; }

	// Methods

	// RVA: 0x257C7DC Offset: 0x257C7DC VA: 0x257C7DC
	public void .ctor() { }

	// RVA: 0x257C884 Offset: 0x257C884 VA: 0x257C884 Slot: 10
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x257CB04 Offset: 0x257CB04 VA: 0x257CB04 Slot: 11
	public virtual string get_AlgorithmName() { }

	// RVA: 0x257CB4C Offset: 0x257CB4C VA: 0x257CB4C Slot: 12
	public virtual bool get_IsPartialBlockOkay() { }

	// RVA: 0x257CB54 Offset: 0x257CB54 VA: 0x257CB54 Slot: 13
	public virtual int ProcessBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x257CCDC Offset: 0x257CCDC VA: 0x257CCDC Slot: 14
	public virtual void Reset() { }

	// RVA: 0x257CCE0 Offset: 0x257CCE0 VA: 0x257CCE0 Slot: 15
	public virtual int GetBlockSize() { }

	// RVA: 0x257CCE8 Offset: 0x257CCE8 VA: 0x257CCE8 Slot: 16
	internal virtual void SetKey(byte[] key) { }

	// RVA: 0x2585238 Offset: 0x2585238 VA: 0x2585238 Slot: 17
	internal virtual int EncryptBlock(byte[] src, int srcIndex, byte[] dst, int dstIndex) { }

	// RVA: 0x2585658 Offset: 0x2585658 VA: 0x2585658 Slot: 18
	internal virtual int DecryptBlock(byte[] src, int srcIndex, byte[] dst, int dstIndex) { }

	// RVA: 0x2585ADC Offset: 0x2585ADC VA: 0x2585ADC
	internal static uint F1(uint D, uint Kmi, int Kri) { }

	// RVA: 0x2585C70 Offset: 0x2585C70 VA: 0x2585C70
	internal static uint F2(uint D, uint Kmi, int Kri) { }

	// RVA: 0x2585E04 Offset: 0x2585E04 VA: 0x2585E04
	internal static uint F3(uint D, uint Kmi, int Kri) { }

	// RVA: 0x258535C Offset: 0x258535C VA: 0x258535C
	internal void CAST_Encipher(uint L0, uint R0, uint[] result) { }

	// RVA: 0x258577C Offset: 0x258577C VA: 0x258577C
	internal void CAST_Decipher(uint L16, uint R16, uint[] result) { }

	// RVA: 0x258513C Offset: 0x258513C VA: 0x258513C
	internal static void Bits32ToInts(uint inData, int[] b, int offset) { }

	// RVA: 0x2585048 Offset: 0x2585048 VA: 0x2585048
	internal static uint IntsTo32bits(int[] b, int i) { }

	// RVA: 0x2585F98 Offset: 0x2585F98 VA: 0x2585F98
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public sealed class Cast6Engine : Cast5Engine // TypeDefIndex: 4700
{
	// Fields
	private const int ROUNDS = 12;
	private const int BLOCK_SIZE = 16;
	private int[] _Kr; // 0x38
	private uint[] _Km; // 0x40
	private int[] _Tr; // 0x48
	private uint[] _Tm; // 0x50
	private uint[] _workingKey; // 0x58

	// Properties
	public override string AlgorithmName { get; }

	// Methods

	// RVA: 0x2586184 Offset: 0x2586184 VA: 0x2586184
	public void .ctor() { }

	// RVA: 0x2586250 Offset: 0x2586250 VA: 0x2586250 Slot: 11
	public override string get_AlgorithmName() { }

	// RVA: 0x2586298 Offset: 0x2586298 VA: 0x2586298 Slot: 14
	public override void Reset() { }

	// RVA: 0x258629C Offset: 0x258629C VA: 0x258629C Slot: 15
	public override int GetBlockSize() { }

	// RVA: 0x25862A4 Offset: 0x25862A4 VA: 0x25862A4 Slot: 16
	internal override void SetKey(byte[] key) { }

	// RVA: 0x25875D4 Offset: 0x25875D4 VA: 0x25875D4 Slot: 17
	internal override int EncryptBlock(byte[] src, int srcIndex, byte[] dst, int dstIndex) { }

	// RVA: 0x2587CFC Offset: 0x2587CFC VA: 0x2587CFC Slot: 18
	internal override int DecryptBlock(byte[] src, int srcIndex, byte[] dst, int dstIndex) { }

	// RVA: 0x2587790 Offset: 0x2587790 VA: 0x2587790
	private void CAST_Encipher(uint A, uint B, uint C, uint D, uint[] result) { }

	// RVA: 0x2587EB8 Offset: 0x2587EB8 VA: 0x2587EB8
	private void CAST_Decipher(uint A, uint B, uint C, uint D, uint[] result) { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class ChaCha7539Engine : Salsa20Engine // TypeDefIndex: 4701
{
	// Properties
	public override string AlgorithmName { get; }
	protected override int NonceSize { get; }

	// Methods

	// RVA: 0x2588428 Offset: 0x2588428 VA: 0x2588428
	public void .ctor() { }

	// RVA: 0x2588490 Offset: 0x2588490 VA: 0x2588490 Slot: 11
	public override string get_AlgorithmName() { }

	// RVA: 0x2588534 Offset: 0x2588534 VA: 0x2588534 Slot: 10
	protected override int get_NonceSize() { }

	// RVA: 0x258853C Offset: 0x258853C VA: 0x258853C Slot: 13
	protected override void AdvanceCounter() { }

	// RVA: 0x25885FC Offset: 0x25885FC VA: 0x25885FC Slot: 16
	protected override void ResetCounter() { }

	// RVA: 0x2588644 Offset: 0x2588644 VA: 0x2588644 Slot: 17
	protected override void SetKey(byte[] keyBytes, byte[] ivBytes) { }

	// RVA: 0x2588790 Offset: 0x2588790 VA: 0x2588790 Slot: 18
	protected override void GenerateKeyStream(byte[] output) { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class ChaChaEngine : Salsa20Engine // TypeDefIndex: 4702
{
	// Properties
	public override string AlgorithmName { get; }

	// Methods

	// RVA: 0x258935C Offset: 0x258935C VA: 0x258935C
	public void .ctor() { }

	// RVA: 0x25893C4 Offset: 0x25893C4 VA: 0x25893C4
	public void .ctor(int rounds) { }

	// RVA: 0x258943C Offset: 0x258943C VA: 0x258943C Slot: 11
	public override string get_AlgorithmName() { }

	// RVA: 0x25894E0 Offset: 0x25894E0 VA: 0x25894E0 Slot: 13
	protected override void AdvanceCounter() { }

	// RVA: 0x2589570 Offset: 0x2589570 VA: 0x2589570 Slot: 16
	protected override void ResetCounter() { }

	// RVA: 0x25895D8 Offset: 0x25895D8 VA: 0x25895D8 Slot: 17
	protected override void SetKey(byte[] keyBytes, byte[] ivBytes) { }

	// RVA: 0x2589748 Offset: 0x2589748 VA: 0x2589748 Slot: 18
	protected override void GenerateKeyStream(byte[] output) { }

	// RVA: 0x25887D0 Offset: 0x25887D0 VA: 0x25887D0
	internal static void ChachaCore(int rounds, uint[] input, uint[] x) { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class DesEdeEngine : DesEngine // TypeDefIndex: 4703
{
	// Fields
	private int[] workingKey1; // 0x18
	private int[] workingKey2; // 0x20
	private int[] workingKey3; // 0x28
	private bool forEncryption; // 0x30

	// Properties
	public override string AlgorithmName { get; }

	// Methods

	// RVA: 0x2589788 Offset: 0x2589788 VA: 0x2589788
	public void .ctor() { }

	// RVA: 0x25897F8 Offset: 0x25897F8 VA: 0x25897F8 Slot: 11
	public override void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x258A254 Offset: 0x258A254 VA: 0x258A254 Slot: 12
	public override string get_AlgorithmName() { }

	// RVA: 0x258A29C Offset: 0x258A29C VA: 0x258A29C Slot: 14
	public override int GetBlockSize() { }

	// RVA: 0x258A2A4 Offset: 0x258A2A4 VA: 0x258A2A4 Slot: 15
	public override int ProcessBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x258AB5C Offset: 0x258AB5C VA: 0x258AB5C Slot: 16
	public override void Reset() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class DesEdeWrapEngine : IWrapper // TypeDefIndex: 4704
{
	// Fields
	private CbcBlockCipher engine; // 0x10
	private KeyParameter param; // 0x18
	private ParametersWithIV paramPlusIV; // 0x20
	private byte[] iv; // 0x28
	private bool forWrapping; // 0x30
	private static readonly byte[] IV2; // 0x0
	private readonly IDigest sha1; // 0x38
	private readonly byte[] digest; // 0x40

	// Properties
	public virtual string AlgorithmName { get; }

	// Methods

	// RVA: 0x258AB60 Offset: 0x258AB60 VA: 0x258AB60
	public void .ctor() { }

	// RVA: 0x258ABE0 Offset: 0x258ABE0 VA: 0x258ABE0 Slot: 8
	public virtual void Init(bool forWrapping, ICipherParameters parameters) { }

	// RVA: 0x258AF20 Offset: 0x258AF20 VA: 0x258AF20 Slot: 9
	public virtual string get_AlgorithmName() { }

	// RVA: 0x258AF68 Offset: 0x258AF68 VA: 0x258AF68 Slot: 10
	public virtual byte[] Wrap(byte[] input, int inOff, int length) { }

	// RVA: 0x258B5F0 Offset: 0x258B5F0 VA: 0x258B5F0 Slot: 11
	public virtual byte[] Unwrap(byte[] input, int inOff, int length) { }

	// RVA: 0x258B348 Offset: 0x258B348 VA: 0x258B348
	private byte[] CalculateCmsKeyChecksum(byte[] key) { }

	// RVA: 0x258BA74 Offset: 0x258BA74 VA: 0x258BA74
	private bool CheckCmsKeyChecksum(byte[] key, byte[] checksum) { }

	// RVA: 0x258B4F4 Offset: 0x258B4F4 VA: 0x258B4F4
	private static byte[] reverse(byte[] bs) { }

	// RVA: 0x258BA9C Offset: 0x258BA9C VA: 0x258BA9C
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class DesEngine : IBlockCipher // TypeDefIndex: 4705
{
	// Fields
	internal const int BLOCK_SIZE = 8;
	private int[] workingKey; // 0x10
	private static readonly short[] bytebit; // 0x0
	private static readonly int[] bigbyte; // 0x8
	private static readonly byte[] pc1; // 0x10
	private static readonly byte[] totrot; // 0x18
	private static readonly byte[] pc2; // 0x20
	private static readonly uint[] SP1; // 0x28
	private static readonly uint[] SP2; // 0x30
	private static readonly uint[] SP3; // 0x38
	private static readonly uint[] SP4; // 0x40
	private static readonly uint[] SP5; // 0x48
	private static readonly uint[] SP6; // 0x50
	private static readonly uint[] SP7; // 0x58
	private static readonly uint[] SP8; // 0x60

	// Properties
	public virtual string AlgorithmName { get; }
	public virtual bool IsPartialBlockOkay { get; }

	// Methods

	// RVA: 0x25897F0 Offset: 0x25897F0 VA: 0x25897F0
	public void .ctor() { }

	// RVA: 0x258BB18 Offset: 0x258BB18 VA: 0x258BB18 Slot: 10
	public virtual int[] GetWorkingKey() { }

	// RVA: 0x258BB20 Offset: 0x258BB20 VA: 0x258BB20 Slot: 11
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x258BC9C Offset: 0x258BC9C VA: 0x258BC9C Slot: 12
	public virtual string get_AlgorithmName() { }

	// RVA: 0x258BCE4 Offset: 0x258BCE4 VA: 0x258BCE4 Slot: 13
	public virtual bool get_IsPartialBlockOkay() { }

	// RVA: 0x258BCEC Offset: 0x258BCEC VA: 0x258BCEC Slot: 14
	public virtual int GetBlockSize() { }

	// RVA: 0x258BCF4 Offset: 0x258BCF4 VA: 0x258BCF4 Slot: 15
	public virtual int ProcessBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x258BE20 Offset: 0x258BE20 VA: 0x258BE20 Slot: 16
	public virtual void Reset() { }

	// RVA: 0x2589AC4 Offset: 0x2589AC4 VA: 0x2589AC4
	protected static int[] GenerateWorkingKey(bool encrypting, byte[] key) { }

	// RVA: 0x258A484 Offset: 0x258A484 VA: 0x258A484
	internal static void DesFunc(int[] wKey, byte[] input, int inOff, byte[] outBytes, int outOff) { }

	// RVA: 0x258BE24 Offset: 0x258BE24 VA: 0x258BE24
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class ElGamalEngine : IAsymmetricBlockCipher // TypeDefIndex: 4706
{
	// Fields
	private ElGamalKeyParameters key; // 0x10
	private SecureRandom random; // 0x18
	private bool forEncryption; // 0x20
	private int bitSize; // 0x24

	// Properties
	public virtual string AlgorithmName { get; }

	// Methods

	// RVA: 0x258C100 Offset: 0x258C100 VA: 0x258C100
	public void .ctor() { }

	// RVA: 0x258C108 Offset: 0x258C108 VA: 0x258C108 Slot: 9
	public virtual string get_AlgorithmName() { }

	// RVA: 0x258C150 Offset: 0x258C150 VA: 0x258C150 Slot: 10
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x258C448 Offset: 0x258C448 VA: 0x258C448 Slot: 11
	public virtual int GetInputBlockSize() { }

	// RVA: 0x258C488 Offset: 0x258C488 VA: 0x258C488 Slot: 12
	public virtual int GetOutputBlockSize() { }

	// RVA: 0x258C4C8 Offset: 0x258C4C8 VA: 0x258C4C8 Slot: 13
	public virtual byte[] ProcessBlock(byte[] input, int inOff, int length) { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class Gost28147Engine : IBlockCipher // TypeDefIndex: 4707
{
	// Fields
	private const int BlockSize = 8;
	private int[] workingKey; // 0x10
	private bool forEncryption; // 0x18
	private byte[] S; // 0x20
	private static readonly byte[] Sbox_Default; // 0x0
	private static readonly byte[] ESbox_Test; // 0x8
	private static readonly byte[] ESbox_A; // 0x10
	private static readonly byte[] ESbox_B; // 0x18
	private static readonly byte[] ESbox_C; // 0x20
	private static readonly byte[] ESbox_D; // 0x28
	private static readonly byte[] DSbox_Test; // 0x30
	private static readonly byte[] DSbox_A; // 0x38
	private static readonly IDictionary sBoxes; // 0x40

	// Properties
	public virtual string AlgorithmName { get; }
	public virtual bool IsPartialBlockOkay { get; }

	// Methods

	// RVA: 0x258CBAC Offset: 0x258CBAC VA: 0x258CBAC
	private static void .cctor() { }

	// RVA: 0x258CFAC Offset: 0x258CFAC VA: 0x258CFAC
	public void .ctor() { }

	// RVA: 0x258CE84 Offset: 0x258CE84 VA: 0x258CE84
	private static void AddSBox(string sBoxName, byte[] sBox) { }

	// RVA: 0x258D024 Offset: 0x258D024 VA: 0x258D024 Slot: 10
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x258D4D0 Offset: 0x258D4D0 VA: 0x258D4D0 Slot: 11
	public virtual string get_AlgorithmName() { }

	// RVA: 0x258D518 Offset: 0x258D518 VA: 0x258D518 Slot: 12
	public virtual bool get_IsPartialBlockOkay() { }

	// RVA: 0x258D520 Offset: 0x258D520 VA: 0x258D520 Slot: 13
	public virtual int GetBlockSize() { }

	// RVA: 0x258D528 Offset: 0x258D528 VA: 0x258D528 Slot: 14
	public virtual int ProcessBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x258D904 Offset: 0x258D904 VA: 0x258D904 Slot: 15
	public virtual void Reset() { }

	// RVA: 0x258D378 Offset: 0x258D378 VA: 0x258D378
	private int[] generateWorkingKey(bool forEncryption, byte[] userKey) { }

	// RVA: 0x258D9FC Offset: 0x258D9FC VA: 0x258D9FC
	private int Gost28147_mainStep(int n1, int key) { }

	// RVA: 0x258D634 Offset: 0x258D634 VA: 0x258D634
	private void Gost28147Func(int[] workingKey, byte[] inBytes, int inOff, byte[] outBytes, int outOff) { }

	// RVA: 0x258D908 Offset: 0x258D908 VA: 0x258D908
	private static int bytesToint(byte[] inBytes, int inOff) { }

	// RVA: 0x258DC30 Offset: 0x258DC30 VA: 0x258DC30
	private static void intTobytes(int num, byte[] outBytes, int outOff) { }

	// RVA: 0x258DD20 Offset: 0x258DD20 VA: 0x258DD20
	public static byte[] GetSBox(string sBoxName) { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class HC128Engine : IStreamCipher // TypeDefIndex: 4708
{
	// Fields
	private uint[] p; // 0x10
	private uint[] q; // 0x18
	private uint cnt; // 0x20
	private byte[] key; // 0x28
	private byte[] iv; // 0x30
	private bool initialised; // 0x38
	private byte[] buf; // 0x40
	private int idx; // 0x48

	// Properties
	public virtual string AlgorithmName { get; }

	// Methods

	// RVA: 0x258DEFC Offset: 0x258DEFC VA: 0x258DEFC
	public void .ctor() { }

	// RVA: 0x258DF84 Offset: 0x258DF84 VA: 0x258DF84
	private static uint F1(uint x) { }

	// RVA: 0x258DFA0 Offset: 0x258DFA0 VA: 0x258DFA0
	private static uint F2(uint x) { }

	// RVA: 0x258DFB0 Offset: 0x258DFB0 VA: 0x258DFB0
	private uint G1(uint x, uint y, uint z) { }

	// RVA: 0x258DFC4 Offset: 0x258DFC4 VA: 0x258DFC4
	private uint G2(uint x, uint y, uint z) { }

	// RVA: 0x258DFD8 Offset: 0x258DFD8 VA: 0x258DFD8
	private static uint RotateLeft(uint x, int bits) { }

	// RVA: 0x258DF94 Offset: 0x258DF94 VA: 0x258DF94
	private static uint RotateRight(uint x, int bits) { }

	// RVA: 0x258DFE8 Offset: 0x258DFE8 VA: 0x258DFE8
	private uint H1(uint x) { }

	// RVA: 0x258E088 Offset: 0x258E088 VA: 0x258E088
	private uint H2(uint x) { }

	// RVA: 0x258E128 Offset: 0x258E128 VA: 0x258E128
	private static uint Mod1024(uint x) { }

	// RVA: 0x258E130 Offset: 0x258E130 VA: 0x258E130
	private static uint Mod512(uint x) { }

	// RVA: 0x258E138 Offset: 0x258E138 VA: 0x258E138
	private static uint Dim(uint x, uint y) { }

	// RVA: 0x258E144 Offset: 0x258E144 VA: 0x258E144
	private uint Step() { }

	// RVA: 0x258E470 Offset: 0x258E470 VA: 0x258E470
	private void Init() { }

	// RVA: 0x258E88C Offset: 0x258E88C VA: 0x258E88C Slot: 9
	public virtual string get_AlgorithmName() { }

	// RVA: 0x258E8D4 Offset: 0x258E8D4 VA: 0x258E8D4 Slot: 10
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x258EB8C Offset: 0x258EB8C VA: 0x258EB8C
	private byte GetByte() { }

	// RVA: 0x258EC24 Offset: 0x258EC24 VA: 0x258EC24 Slot: 11
	public virtual void ProcessBytes(byte[] input, int inOff, int len, byte[] output, int outOff) { }

	// RVA: 0x258EE08 Offset: 0x258EE08 VA: 0x258EE08 Slot: 12
	public virtual void Reset() { }

	// RVA: 0x258EE0C Offset: 0x258EE0C VA: 0x258EE0C Slot: 13
	public virtual byte ReturnByte(byte input) { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class HC256Engine : IStreamCipher // TypeDefIndex: 4709
{
	// Fields
	private uint[] p; // 0x10
	private uint[] q; // 0x18
	private uint cnt; // 0x20
	private byte[] key; // 0x28
	private byte[] iv; // 0x30
	private bool initialised; // 0x38
	private byte[] buf; // 0x40
	private int idx; // 0x48

	// Properties
	public virtual string AlgorithmName { get; }

	// Methods

	// RVA: 0x258EE30 Offset: 0x258EE30 VA: 0x258EE30
	public void .ctor() { }

	// RVA: 0x258EEB8 Offset: 0x258EEB8 VA: 0x258EEB8
	private uint Step() { }

	// RVA: 0x258F45C Offset: 0x258F45C VA: 0x258F45C
	private void Init() { }

	// RVA: 0x258F954 Offset: 0x258F954 VA: 0x258F954 Slot: 9
	public virtual string get_AlgorithmName() { }

	// RVA: 0x258F99C Offset: 0x258F99C VA: 0x258F99C Slot: 10
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x258FC54 Offset: 0x258FC54 VA: 0x258FC54
	private byte GetByte() { }

	// RVA: 0x258FCEC Offset: 0x258FCEC VA: 0x258FCEC Slot: 11
	public virtual void ProcessBytes(byte[] input, int inOff, int len, byte[] output, int outOff) { }

	// RVA: 0x258FED0 Offset: 0x258FED0 VA: 0x258FED0 Slot: 12
	public virtual void Reset() { }

	// RVA: 0x258FED4 Offset: 0x258FED4 VA: 0x258FED4 Slot: 13
	public virtual byte ReturnByte(byte input) { }

	// RVA: 0x258F450 Offset: 0x258F450 VA: 0x258F450
	private static uint RotateRight(uint x, int bits) { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class IdeaEngine : IBlockCipher // TypeDefIndex: 4710
{
	// Fields
	private const int BLOCK_SIZE = 8;
	private int[] workingKey; // 0x10
	private static readonly int MASK; // 0x0
	private static readonly int BASE; // 0x4

	// Properties
	public virtual string AlgorithmName { get; }
	public virtual bool IsPartialBlockOkay { get; }

	// Methods

	// RVA: 0x258FEF8 Offset: 0x258FEF8 VA: 0x258FEF8
	public void .ctor() { }

	// RVA: 0x258FF00 Offset: 0x258FF00 VA: 0x258FF00 Slot: 10
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x2590094 Offset: 0x2590094 VA: 0x2590094 Slot: 11
	public virtual string get_AlgorithmName() { }

	// RVA: 0x25900DC Offset: 0x25900DC VA: 0x25900DC Slot: 12
	public virtual bool get_IsPartialBlockOkay() { }

	// RVA: 0x25900E4 Offset: 0x25900E4 VA: 0x25900E4 Slot: 13
	public virtual int GetBlockSize() { }

	// RVA: 0x25900EC Offset: 0x25900EC VA: 0x25900EC Slot: 14
	public virtual int ProcessBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x2590578 Offset: 0x2590578 VA: 0x2590578 Slot: 15
	public virtual void Reset() { }

	// RVA: 0x259057C Offset: 0x259057C VA: 0x259057C
	private int BytesToWord(byte[] input, int inOff) { }

	// RVA: 0x2590608 Offset: 0x2590608 VA: 0x2590608
	private void WordToBytes(int word, byte[] outBytes, int outOff) { }

	// RVA: 0x2590698 Offset: 0x2590698 VA: 0x2590698
	private int Mul(int x, int y) { }

	// RVA: 0x25901F8 Offset: 0x25901F8 VA: 0x25901F8
	private void IdeaFunc(int[] workingKey, byte[] input, int inOff, byte[] outBytes, int outOff) { }

	// RVA: 0x25907BC Offset: 0x25907BC VA: 0x25907BC
	private int[] ExpandKey(byte[] uKey) { }

	// RVA: 0x2590A38 Offset: 0x2590A38 VA: 0x2590A38
	private int MulInv(int x) { }

	// RVA: 0x2590B78 Offset: 0x2590B78 VA: 0x2590B78
	private int AddInv(int x) { }

	// RVA: 0x2590BEC Offset: 0x2590BEC VA: 0x2590BEC
	private int[] InvertKey(int[] inKey) { }

	// RVA: 0x259005C Offset: 0x259005C VA: 0x259005C
	private int[] GenerateWorkingKey(bool forEncryption, byte[] userKey) { }

	// RVA: 0x25910C4 Offset: 0x25910C4 VA: 0x25910C4
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class IesEngine // TypeDefIndex: 4711
{
	// Fields
	private readonly IBasicAgreement agree; // 0x10
	private readonly IDerivationFunction kdf; // 0x18
	private readonly IMac mac; // 0x20
	private readonly BufferedBlockCipher cipher; // 0x28
	private readonly byte[] macBuf; // 0x30
	private bool forEncryption; // 0x38
	private ICipherParameters privParam; // 0x40
	private ICipherParameters pubParam; // 0x48
	private IesParameters param; // 0x50

	// Methods

	// RVA: 0x2591128 Offset: 0x2591128 VA: 0x2591128
	public void .ctor(IBasicAgreement agree, IDerivationFunction kdf, IMac mac) { }

	// RVA: 0x259122C Offset: 0x259122C VA: 0x259122C
	public void .ctor(IBasicAgreement agree, IDerivationFunction kdf, IMac mac, BufferedBlockCipher cipher) { }

	// RVA: 0x2591334 Offset: 0x2591334 VA: 0x2591334 Slot: 4
	public virtual void Init(bool forEncryption, ICipherParameters privParameters, ICipherParameters pubParameters, ICipherParameters iesParameters) { }

	// RVA: 0x259142C Offset: 0x259142C VA: 0x259142C
	private byte[] DecryptBlock(byte[] in_enc, int inOff, int inLen, byte[] z) { }

	// RVA: 0x2591DF4 Offset: 0x2591DF4 VA: 0x2591DF4
	private byte[] EncryptBlock(byte[] input, int inOff, int inLen, byte[] z) { }

	// RVA: 0x2591C6C Offset: 0x2591C6C VA: 0x2591C6C
	private byte[] GenerateKdfBytes(KdfParameters kParam, int length) { }

	// RVA: 0x25925C8 Offset: 0x25925C8 VA: 0x25925C8 Slot: 5
	public virtual byte[] ProcessBlock(byte[] input, int inOff, int inLen) { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class NoekeonEngine : IBlockCipher // TypeDefIndex: 4712
{
	// Fields
	private const int GenericSize = 16;
	private static readonly uint[] nullVector; // 0x0
	private static readonly uint[] roundConstants; // 0x8
	private uint[] state; // 0x10
	private uint[] subKeys; // 0x18
	private uint[] decryptKeys; // 0x20
	private bool _initialised; // 0x28
	private bool _forEncryption; // 0x29

	// Properties
	public virtual string AlgorithmName { get; }
	public virtual bool IsPartialBlockOkay { get; }

	// Methods

	// RVA: 0x2592868 Offset: 0x2592868 VA: 0x2592868
	public void .ctor() { }

	// RVA: 0x25928F0 Offset: 0x25928F0 VA: 0x25928F0 Slot: 10
	public virtual string get_AlgorithmName() { }

	// RVA: 0x2592938 Offset: 0x2592938 VA: 0x2592938 Slot: 11
	public virtual bool get_IsPartialBlockOkay() { }

	// RVA: 0x2592940 Offset: 0x2592940 VA: 0x2592940 Slot: 12
	public virtual int GetBlockSize() { }

	// RVA: 0x2592948 Offset: 0x2592948 VA: 0x2592948 Slot: 13
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x2592C68 Offset: 0x2592C68 VA: 0x2592C68 Slot: 14
	public virtual int ProcessBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x25935A4 Offset: 0x25935A4 VA: 0x25935A4 Slot: 15
	public virtual void Reset() { }

	// RVA: 0x2592B34 Offset: 0x2592B34 VA: 0x2592B34
	private void setKey(byte[] key) { }

	// RVA: 0x2592DE4 Offset: 0x2592DE4 VA: 0x2592DE4
	private int encryptBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x2593198 Offset: 0x2593198 VA: 0x2593198
	private int decryptBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x2593874 Offset: 0x2593874 VA: 0x2593874
	private void gamma(uint[] a) { }

	// RVA: 0x25935A8 Offset: 0x25935A8 VA: 0x25935A8
	private void theta(uint[] a, uint[] k) { }

	// RVA: 0x2593780 Offset: 0x2593780 VA: 0x2593780
	private void pi1(uint[] a) { }

	// RVA: 0x2593B50 Offset: 0x2593B50 VA: 0x2593B50
	private void pi2(uint[] a) { }

	// RVA: 0x2593C44 Offset: 0x2593C44 VA: 0x2593C44
	private uint rotl(uint x, int y) { }

	// RVA: 0x2593C54 Offset: 0x2593C54 VA: 0x2593C54
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class RC2Engine : IBlockCipher // TypeDefIndex: 4713
{
	// Fields
	private static readonly byte[] piTable; // 0x0
	private const int BLOCK_SIZE = 8;
	private int[] workingKey; // 0x10
	private bool encrypting; // 0x18

	// Properties
	public virtual string AlgorithmName { get; }
	public virtual bool IsPartialBlockOkay { get; }

	// Methods

	// RVA: 0x2593CE8 Offset: 0x2593CE8 VA: 0x2593CE8
	public void .ctor() { }

	// RVA: 0x2593CF0 Offset: 0x2593CF0 VA: 0x2593CF0
	private int[] GenerateWorkingKey(byte[] key, int bits) { }

	// RVA: 0x2594158 Offset: 0x2594158 VA: 0x2594158 Slot: 10
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x2594318 Offset: 0x2594318 VA: 0x2594318 Slot: 11
	public virtual void Reset() { }

	// RVA: 0x259431C Offset: 0x259431C VA: 0x259431C Slot: 12
	public virtual string get_AlgorithmName() { }

	// RVA: 0x2594364 Offset: 0x2594364 VA: 0x2594364 Slot: 13
	public virtual bool get_IsPartialBlockOkay() { }

	// RVA: 0x259436C Offset: 0x259436C VA: 0x259436C Slot: 14
	public virtual int GetBlockSize() { }

	// RVA: 0x2594374 Offset: 0x2594374 VA: 0x2594374 Slot: 15
	public virtual int ProcessBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x25957E8 Offset: 0x25957E8 VA: 0x25957E8
	private int RotateWordLeft(int x, int y) { }

	// RVA: 0x25944A0 Offset: 0x25944A0 VA: 0x25944A0
	private void EncryptBlock(byte[] input, int inOff, byte[] outBytes, int outOff) { }

	// RVA: 0x2594E64 Offset: 0x2594E64 VA: 0x2594E64
	private void DecryptBlock(byte[] input, int inOff, byte[] outBytes, int outOff) { }

	// RVA: 0x259580C Offset: 0x259580C VA: 0x259580C
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class RC2WrapEngine : IWrapper // TypeDefIndex: 4714
{
	// Fields
	private CbcBlockCipher engine; // 0x10
	private ICipherParameters parameters; // 0x18
	private ParametersWithIV paramPlusIV; // 0x20
	private byte[] iv; // 0x28
	private bool forWrapping; // 0x30
	private SecureRandom sr; // 0x38
	private static readonly byte[] IV2; // 0x0
	private IDigest sha1; // 0x40
	private byte[] digest; // 0x48

	// Properties
