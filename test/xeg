
// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC3561C Offset: 0xC3561C VA: 0xC3561C
public class HMACSHA384 : HMAC // TypeDefIndex: 732
{
	// Fields
	private static bool legacy_mode; // 0x0
	private bool legacy; // 0x54

	// Properties
	public bool ProduceLegacyHmacValues { get; set; }

	// Methods

	// RVA: 0xE394A8 Offset: 0xE394A8 VA: 0xE394A8
	public void .ctor() { }

	// RVA: 0xE39550 Offset: 0xE39550 VA: 0xE39550
	public void .ctor(byte[] key) { }

	// RVA: 0xE3966C Offset: 0xE3966C VA: 0xE3966C
	private static void .cctor() { }

	// RVA: 0xE39714 Offset: 0xE39714 VA: 0xE39714
	public bool get_ProduceLegacyHmacValues() { }

	// RVA: 0xE3962C Offset: 0xE3962C VA: 0xE3962C
	public void set_ProduceLegacyHmacValues(bool value) { }
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC35630 Offset: 0xC35630 VA: 0xC35630
public class HMACSHA512 : HMAC // TypeDefIndex: 733
{
	// Fields
	private static bool legacy_mode; // 0x0
	private bool legacy; // 0x54

	// Properties
	public bool ProduceLegacyHmacValues { get; set; }

	// Methods

	// RVA: 0xE3971C Offset: 0xE3971C VA: 0xE3971C
	public void .ctor() { }

	// RVA: 0xE397C4 Offset: 0xE397C4 VA: 0xE397C4
	public void .ctor(byte[] key) { }

	// RVA: 0xE398E0 Offset: 0xE398E0 VA: 0xE398E0
	private static void .cctor() { }

	// RVA: 0xE39988 Offset: 0xE39988 VA: 0xE39988
	public bool get_ProduceLegacyHmacValues() { }

	// RVA: 0xE398A0 Offset: 0xE398A0 VA: 0xE398A0
	public void set_ProduceLegacyHmacValues(bool value) { }
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC35644 Offset: 0xC35644 VA: 0xC35644
public abstract class HashAlgorithm : IDisposable, ICryptoTransform // TypeDefIndex: 734
{
	// Fields
	protected internal byte[] HashValue; // 0x10
	protected int HashSizeValue; // 0x18
	protected int State; // 0x1C
	private bool disposed; // 0x20

	// Properties
	public virtual bool CanTransformMultipleBlocks { get; }
	public virtual bool CanReuseTransform { get; }
	public virtual byte[] Hash { get; }
	public virtual int HashSize { get; }
	public virtual int InputBlockSize { get; }
	public virtual int OutputBlockSize { get; }

	// Methods

	// RVA: 0xE39990 Offset: 0xE39990 VA: 0xE39990
	protected void .ctor() { }

	// RVA: 0xE399B8 Offset: 0xE399B8 VA: 0xE399B8 Slot: 4
	private void System.IDisposable.Dispose() { }

	// RVA: 0xE399F0 Offset: 0xE399F0 VA: 0xE399F0 Slot: 11
	public virtual bool get_CanTransformMultipleBlocks() { }

	// RVA: 0xE399F8 Offset: 0xE399F8 VA: 0xE399F8 Slot: 12
	public virtual bool get_CanReuseTransform() { }

	// RVA: 0xE39A00 Offset: 0xE39A00 VA: 0xE39A00
	public void Clear() { }

	// RVA: 0xE382AC Offset: 0xE382AC VA: 0xE382AC
	public byte[] ComputeHash(byte[] buffer) { }

	// RVA: 0xE39A14 Offset: 0xE39A14 VA: 0xE39A14
	public byte[] ComputeHash(byte[] buffer, int offset, int count) { }

	// RVA: 0xE39C1C Offset: 0xE39C1C VA: 0xE39C1C
	public byte[] ComputeHash(Stream inputStream) { }

	// RVA: 0xE39D80 Offset: 0xE39D80 VA: 0xE39D80
	public static HashAlgorithm Create() { }

	// RVA: 0xE37EE0 Offset: 0xE37EE0 VA: 0xE37EE0
	public static HashAlgorithm Create(string hashName) { }

	// RVA: 0xE39DC8 Offset: 0xE39DC8 VA: 0xE39DC8 Slot: 13
	public virtual byte[] get_Hash() { }

	// RVA: -1 Offset: -1 Slot: 14
	protected abstract void HashCore(byte[] array, int ibStart, int cbSize);

	// RVA: -1 Offset: -1 Slot: 15
	protected abstract byte[] HashFinal();

	// RVA: 0xE39E68 Offset: 0xE39E68 VA: 0xE39E68 Slot: 16
	public virtual int get_HashSize() { }

	// RVA: -1 Offset: -1 Slot: 17
	public abstract void Initialize();

	// RVA: 0xE39E70 Offset: 0xE39E70 VA: 0xE39E70 Slot: 18
	protected virtual void Dispose(bool disposing) { }

	// RVA: 0xE39E7C Offset: 0xE39E7C VA: 0xE39E7C Slot: 19
	public virtual int get_InputBlockSize() { }

	// RVA: 0xE39E84 Offset: 0xE39E84 VA: 0xE39E84 Slot: 20
	public virtual int get_OutputBlockSize() { }

	// RVA: 0xE38A10 Offset: 0xE38A10 VA: 0xE38A10 Slot: 9
	public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset) { }

	// RVA: 0xE38C4C Offset: 0xE38C4C VA: 0xE38C4C Slot: 10
	public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount) { }
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC35658 Offset: 0xC35658 VA: 0xC35658
public interface ICryptoTransform : IDisposable // TypeDefIndex: 735
{
	// Properties
	public abstract bool CanReuseTransform { get; }
	public abstract bool CanTransformMultipleBlocks { get; }
	public abstract int InputBlockSize { get; }
	public abstract int OutputBlockSize { get; }

	// Methods

	// RVA: -1 Offset: -1 Slot: 0
	public abstract bool get_CanReuseTransform();

	// RVA: -1 Offset: -1 Slot: 1
	public abstract bool get_CanTransformMultipleBlocks();

	// RVA: -1 Offset: -1 Slot: 2
	public abstract int get_InputBlockSize();

	// RVA: -1 Offset: -1 Slot: 3
	public abstract int get_OutputBlockSize();

	// RVA: -1 Offset: -1 Slot: 4
	public abstract int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);

	// RVA: -1 Offset: -1 Slot: 5
	public abstract byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC3566C Offset: 0xC3566C VA: 0xC3566C
public interface ICspAsymmetricAlgorithm // TypeDefIndex: 736
{
	// Properties
	public abstract CspKeyContainerInfo CspKeyContainerInfo { get; }

	// Methods

	// RVA: -1 Offset: -1 Slot: 0
	public abstract byte[] ExportCspBlob(bool includePrivateParameters);

	// RVA: -1 Offset: -1 Slot: 1
	public abstract void ImportCspBlob(byte[] rawData);

	// RVA: -1 Offset: -1 Slot: 2
	public abstract CspKeyContainerInfo get_CspKeyContainerInfo();
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC35680 Offset: 0xC35680 VA: 0xC35680
[Serializable]
public enum KeyNumber // TypeDefIndex: 737
{
	// Fields
	public int value__; // 0x0
	public const KeyNumber Exchange = 1;
	public const KeyNumber Signature = 2;
}

// Namespace: System.Security.Cryptography
public sealed class KeySizes // TypeDefIndex: 738
{
	// Fields
	private int _maxSize; // 0x10
	private int _minSize; // 0x14
	private int _skipSize; // 0x18

	// Properties
	public int MaxSize { get; }
	public int MinSize { get; }
	public int SkipSize { get; }

	// Methods

	// RVA: 0xE39E8C Offset: 0xE39E8C VA: 0xE39E8C
	public void .ctor(int minSize, int maxSize, int skipSize) { }

	// RVA: 0xE39ECC Offset: 0xE39ECC VA: 0xE39ECC
	public int get_MaxSize() { }

	// RVA: 0xE39ED4 Offset: 0xE39ED4 VA: 0xE39ED4
	public int get_MinSize() { }

	// RVA: 0xE39EDC Offset: 0xE39EDC VA: 0xE39EDC
	public int get_SkipSize() { }

	// RVA: 0xE39EE4 Offset: 0xE39EE4 VA: 0xE39EE4
	internal bool IsLegal(int keySize) { }

	// RVA: 0xE39F34 Offset: 0xE39F34 VA: 0xE39F34
	internal static bool IsLegalKeySize(KeySizes[] legalKeys, int size) { }
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC35694 Offset: 0xC35694 VA: 0xC35694
public abstract class KeyedHashAlgorithm : HashAlgorithm // TypeDefIndex: 739
{
	// Fields
	protected byte[] KeyValue; // 0x28

	// Properties
	public virtual byte[] Key { get; set; }

	// Methods

	// RVA: 0xE37E74 Offset: 0xE37E74 VA: 0xE37E74
	protected void .ctor() { }

	// RVA: 0xE39FF8 Offset: 0xE39FF8 VA: 0xE39FF8 Slot: 1
	protected override void Finalize() { }

	// RVA: 0xE380B0 Offset: 0xE380B0 VA: 0xE380B0 Slot: 21
	public virtual byte[] get_Key() { }

	// RVA: 0xE38350 Offset: 0xE38350 VA: 0xE38350 Slot: 22
	public virtual void set_Key(byte[] value) { }

	// RVA: 0xE386CC Offset: 0xE386CC VA: 0xE386CC Slot: 18
	protected override void Dispose(bool disposing) { }

	// RVA: 0xE3A07C Offset: 0xE3A07C VA: 0xE3A07C
	private void ZeroizeKey() { }

	// RVA: 0xE3A098 Offset: 0xE3A098 VA: 0xE3A098
	public static KeyedHashAlgorithm Create() { }

	// RVA: 0xE3A0E0 Offset: 0xE3A0E0 VA: 0xE3A0E0
	public static KeyedHashAlgorithm Create(string algName) { }
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC356A8 Offset: 0xC356A8 VA: 0xC356A8
public class MACTripleDES : KeyedHashAlgorithm // TypeDefIndex: 740
{
	// Fields
	private TripleDES tdes; // 0x30
	private MACAlgorithm mac; // 0x38
	private bool m_disposed; // 0x40

	// Properties
	[ComVisibleAttribute] // RVA: 0xC3B3A0 Offset: 0xC3B3A0 VA: 0xC3B3A0
	public PaddingMode Padding { get; set; }

	// Methods

	// RVA: 0xE3A1D4 Offset: 0xE3A1D4 VA: 0xE3A1D4
	public void .ctor() { }

	// RVA: 0xE3A36C Offset: 0xE3A36C VA: 0xE3A36C
	public void .ctor(byte[] rgbKey) { }

	// RVA: 0xE3A424 Offset: 0xE3A424 VA: 0xE3A424
	public void .ctor(string strTripleDES, byte[] rgbKey) { }

	// RVA: 0xE3A238 Offset: 0xE3A238 VA: 0xE3A238
	private void Setup(string strTripleDES, byte[] rgbKey) { }

	// RVA: 0xE3A4F0 Offset: 0xE3A4F0 VA: 0xE3A4F0 Slot: 1
	protected override void Finalize() { }

	// RVA: 0xE3A56C Offset: 0xE3A56C VA: 0xE3A56C
	public PaddingMode get_Padding() { }

	// RVA: 0xE3A5A4 Offset: 0xE3A5A4 VA: 0xE3A5A4
	public void set_Padding(PaddingMode value) { }

	// RVA: 0xE3A5E4 Offset: 0xE3A5E4 VA: 0xE3A5E4 Slot: 18
	protected override void Dispose(bool disposing) { }

	// RVA: 0xE3A670 Offset: 0xE3A670 VA: 0xE3A670 Slot: 17
	public override void Initialize() { }

	// RVA: 0xE3A728 Offset: 0xE3A728 VA: 0xE3A728 Slot: 14
	protected override void HashCore(byte[] rgbData, int ibStart, int cbSize) { }

	// RVA: 0xE3A818 Offset: 0xE3A818 VA: 0xE3A818 Slot: 15
	protected override byte[] HashFinal() { }
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC356BC Offset: 0xC356BC VA: 0xC356BC
public abstract class MD5 : HashAlgorithm // TypeDefIndex: 741
{
	// Methods

	// RVA: 0xE3A8C0 Offset: 0xE3A8C0 VA: 0xE3A8C0
	protected void .ctor() { }

	// RVA: 0xE3A8F0 Offset: 0xE3A8F0 VA: 0xE3A8F0
	public static MD5 Create() { }

	// RVA: 0xE3A938 Offset: 0xE3A938 VA: 0xE3A938
	public static MD5 Create(string algName) { }
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC356D0 Offset: 0xC356D0 VA: 0xC356D0
public sealed class MD5CryptoServiceProvider : MD5 // TypeDefIndex: 742
{
	// Fields
	private const int BLOCK_SIZE_BYTES = 64;
	private const int HASH_SIZE_BYTES = 16;
	private uint[] _H; // 0x28
	private uint[] buff; // 0x30
	private ulong count; // 0x38
	private byte[] _ProcessingBuffer; // 0x40
	private int _ProcessingBufferCount; // 0x48
	private static readonly uint[] K; // 0x0

	// Methods

	// RVA: 0xE3AA2C Offset: 0xE3AA2C VA: 0xE3AA2C
	public void .ctor() { }

	// RVA: 0xE3ABC8 Offset: 0xE3ABC8 VA: 0xE3ABC8
	private static void .cctor() { }

	// RVA: 0xE3AC44 Offset: 0xE3AC44 VA: 0xE3AC44 Slot: 1
	protected override void Finalize() { }

	// RVA: 0xE3AC54 Offset: 0xE3AC54 VA: 0xE3AC54 Slot: 18
	protected override void Dispose(bool disposing) { }

	// RVA: 0xE3ACD0 Offset: 0xE3ACD0 VA: 0xE3ACD0 Slot: 14
	protected override void HashCore(byte[] rgb, int ibStart, int cbSize) { }

	// RVA: 0xE3D28C Offset: 0xE3D28C VA: 0xE3D28C Slot: 15
	protected override byte[] HashFinal() { }

	// RVA: 0xE3AAC8 Offset: 0xE3AAC8 VA: 0xE3AAC8 Slot: 17
	public override void Initialize() { }

	// RVA: 0xE3ADDC Offset: 0xE3ADDC VA: 0xE3ADDC
	private void ProcessBlock(byte[] inputBuffer, int inputOffset) { }

	// RVA: 0xE3D3B0 Offset: 0xE3D3B0 VA: 0xE3D3B0
	private void ProcessFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount) { }

	// RVA: 0xE3D5D8 Offset: 0xE3D5D8 VA: 0xE3D5D8
	internal void AddLength(ulong length, byte[] buffer, int position) { }
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC356E4 Offset: 0xC356E4 VA: 0xC356E4
public abstract class MaskGenerationMethod // TypeDefIndex: 743
{
	// Methods

	// RVA: 0xE3D790 Offset: 0xE3D790 VA: 0xE3D790
	protected void .ctor() { }

	[ComVisibleAttribute] // RVA: 0xC397B8 Offset: 0xC397B8 VA: 0xC397B8
	// RVA: -1 Offset: -1 Slot: 4
	public abstract byte[] GenerateMask(byte[] rgbSeed, int cbReturn);
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC356F8 Offset: 0xC356F8 VA: 0xC356F8
public class PKCS1MaskGenerationMethod : MaskGenerationMethod // TypeDefIndex: 744
{
	// Fields
	private string hashName; // 0x10

	// Properties
	public string HashName { get; set; }

	// Methods

	// RVA: 0xE3D798 Offset: 0xE3D798 VA: 0xE3D798
	public void .ctor() { }

	// RVA: 0xE3D7F4 Offset: 0xE3D7F4 VA: 0xE3D7F4
	public string get_HashName() { }

	// RVA: 0xE3D7FC Offset: 0xE3D7FC VA: 0xE3D7FC
	public void set_HashName(string value) { }

	// RVA: 0xE3D86C Offset: 0xE3D86C VA: 0xE3D86C Slot: 4
	public override byte[] GenerateMask(byte[] rgbSeed, int cbReturn) { }
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC3570C Offset: 0xC3570C VA: 0xC3570C
[Serializable]
public enum PaddingMode // TypeDefIndex: 745
{
	// Fields
	public int value__; // 0x0
	public const PaddingMode None = 1;
	public const PaddingMode PKCS7 = 2;
	public const PaddingMode Zeros = 3;
	public const PaddingMode ANSIX923 = 4;
	public const PaddingMode ISO10126 = 5;
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC35720 Offset: 0xC35720 VA: 0xC35720
public class PasswordDeriveBytes : DeriveBytes // TypeDefIndex: 746
{
	// Fields
	private string HashNameValue; // 0x10
	private byte[] SaltValue; // 0x18
	private int IterationsValue; // 0x20
	private HashAlgorithm hash; // 0x28
	private int state; // 0x30
	private byte[] password; // 0x38
	private byte[] initial; // 0x40
	private byte[] output; // 0x48
	private int position; // 0x50
	private int hashnumber; // 0x54

	// Properties
	public string HashName { get; set; }
	public int IterationCount { get; set; }
	public byte[] Salt { get; set; }

	// Methods

	// RVA: 0xE3D8FC Offset: 0xE3D8FC VA: 0xE3D8FC
	public void .ctor(string strPassword, byte[] rgbSalt) { }

	// RVA: 0xE3DA9C Offset: 0xE3DA9C VA: 0xE3DA9C
	public void .ctor(string strPassword, byte[] rgbSalt, CspParameters cspParams) { }

	// RVA: 0xE3DB80 Offset: 0xE3DB80 VA: 0xE3DB80
	public void .ctor(string strPassword, byte[] rgbSalt, string strHashName, int iterations) { }

	// RVA: 0xE3DBD8 Offset: 0xE3DBD8 VA: 0xE3DBD8
	public void .ctor(string strPassword, byte[] rgbSalt, string strHashName, int iterations, CspParameters cspParams) { }

	// RVA: 0xE3DCC4 Offset: 0xE3DCC4 VA: 0xE3DCC4
	public void .ctor(byte[] password, byte[] salt) { }

	// RVA: 0xE3DE98 Offset: 0xE3DE98 VA: 0xE3DE98
	public void .ctor(byte[] password, byte[] salt, CspParameters cspParams) { }

	// RVA: 0xE3DF7C Offset: 0xE3DF7C VA: 0xE3DF7C
	public void .ctor(byte[] password, byte[] salt, string hashName, int iterations) { }

	// RVA: 0xE3DFD4 Offset: 0xE3DFD4 VA: 0xE3DFD4
	public void .ctor(byte[] password, byte[] salt, string hashName, int iterations, CspParameters cspParams) { }

	// RVA: 0xE3E0C0 Offset: 0xE3E0C0 VA: 0xE3E0C0 Slot: 1
	protected override void Finalize() { }

	// RVA: 0xE3D974 Offset: 0xE3D974 VA: 0xE3D974
	private void Prepare(string strPassword, byte[] rgbSalt, string strHashName, int iterations) { }

	// RVA: 0xE3DD3C Offset: 0xE3DD3C VA: 0xE3DD3C
	private void Prepare(byte[] password, byte[] rgbSalt, string strHashName, int iterations) { }

	// RVA: 0xE3E490 Offset: 0xE3E490 VA: 0xE3E490
	public string get_HashName() { }

	// RVA: 0xE3E2A8 Offset: 0xE3E2A8 VA: 0xE3E2A8
	public void set_HashName(string value) { }

	// RVA: 0xE3E498 Offset: 0xE3E498 VA: 0xE3E498
	public int get_IterationCount() { }

	// RVA: 0xE3E394 Offset: 0xE3E394 VA: 0xE3E394
	public void set_IterationCount(int value) { }

	// RVA: 0xE3E4A0 Offset: 0xE3E4A0 VA: 0xE3E4A0
	public byte[] get_Salt() { }

	// RVA: 0xE3E174 Offset: 0xE3E174 VA: 0xE3E174
	public void set_Salt(byte[] value) { }

	// RVA: 0xE3E56C Offset: 0xE3E56C VA: 0xE3E56C
	public byte[] CryptDeriveKey(string algname, string alghashname, int keySize, byte[] rgbIV) { }

	[ObsoleteAttribute] // RVA: 0xC397CC Offset: 0xC397CC VA: 0xC397CC
	// RVA: 0xE3E640 Offset: 0xE3E640 VA: 0xE3E640 Slot: 4
	public override byte[] GetBytes(int cb) { }

	// RVA: 0xE3EA00 Offset: 0xE3EA00 VA: 0xE3EA00 Slot: 5
	public override void Reset() { }
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC35734 Offset: 0xC35734 VA: 0xC35734
public abstract class RC2 : SymmetricAlgorithm // TypeDefIndex: 747
{
	// Fields
	protected int EffectiveKeySizeValue; // 0x50

	// Properties
	public virtual int EffectiveKeySize { get; set; }
	public override int KeySize { get; set; }

	// Methods

	// RVA: 0xE3EB08 Offset: 0xE3EB08 VA: 0xE3EB08
	protected void .ctor() { }

	// RVA: 0xE3ECA8 Offset: 0xE3ECA8 VA: 0xE3ECA8
	public static RC2 Create() { }

	// RVA: 0xE3ECF0 Offset: 0xE3ECF0 VA: 0xE3ECF0
	public static RC2 Create(string AlgName) { }

	// RVA: 0xE3EDE4 Offset: 0xE3EDE4 VA: 0xE3EDE4 Slot: 28
	public virtual int get_EffectiveKeySize() { }

	// RVA: 0xE3EDFC Offset: 0xE3EDFC VA: 0xE3EDFC Slot: 29
	public virtual void set_EffectiveKeySize(int value) { }

	// RVA: 0xE3EE04 Offset: 0xE3EE04 VA: 0xE3EE04 Slot: 14
	public override int get_KeySize() { }

	// RVA: 0xE3EE0C Offset: 0xE3EE0C VA: 0xE3EE0C Slot: 15
	public override void set_KeySize(int value) { }
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC35748 Offset: 0xC35748 VA: 0xC35748
public sealed class RC2CryptoServiceProvider : RC2 // TypeDefIndex: 748
{
	// Fields
	private bool _useSalt; // 0x54

	// Properties
	public override int EffectiveKeySize { get; set; }
	[MonoTODOAttribute] // RVA: 0xC3B3B4 Offset: 0xC3B3B4 VA: 0xC3B3B4
	[ComVisibleAttribute] // RVA: 0xC3B3B4 Offset: 0xC3B3B4 VA: 0xC3B3B4
	public bool UseSalt { get; set; }

	// Methods

	// RVA: 0xE3EE38 Offset: 0xE3EE38 VA: 0xE3EE38
	public void .ctor() { }

	// RVA: 0xE3EE3C Offset: 0xE3EE3C VA: 0xE3EE3C Slot: 28
	public override int get_EffectiveKeySize() { }

	// RVA: 0xE3EE54 Offset: 0xE3EE54 VA: 0xE3EE54 Slot: 29
	public override void set_EffectiveKeySize(int value) { }

	// RVA: 0xE3EF08 Offset: 0xE3EF08 VA: 0xE3EF08 Slot: 23
	public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV) { }

	// RVA: 0xE3F71C Offset: 0xE3F71C VA: 0xE3F71C Slot: 25
	public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV) { }

	// RVA: 0xE3F798 Offset: 0xE3F798 VA: 0xE3F798 Slot: 26
	public override void GenerateIV() { }

	// RVA: 0xE3F7C8 Offset: 0xE3F7C8 VA: 0xE3F7C8 Slot: 27
	public override void GenerateKey() { }

	// RVA: 0xE3F7F8 Offset: 0xE3F7F8 VA: 0xE3F7F8
	public bool get_UseSalt() { }

	// RVA: 0xE3F800 Offset: 0xE3F800 VA: 0xE3F800
	public void set_UseSalt(bool value) { }
}

// Namespace: System.Security.Cryptography
internal class RC2Transform : SymmetricTransform // TypeDefIndex: 749
{
	// Fields
	private ushort R0; // 0x58
	private ushort R1; // 0x5A
	private ushort R2; // 0x5C
	private ushort R3; // 0x5E
	private ushort[] K; // 0x60
	private int j; // 0x68
	private static readonly byte[] pitable; // 0x0

	// Methods

	// RVA: 0xE3EF84 Offset: 0xE3EF84 VA: 0xE3EF84
	public void .ctor(RC2 rc2Algo, bool encryption, byte[] key, byte[] iv) { }

	// RVA: 0xE3F80C Offset: 0xE3F80C VA: 0xE3F80C
	private static void .cctor() { }

	// RVA: 0xE3F888 Offset: 0xE3F888 VA: 0xE3F888 Slot: 17
	protected override void ECB(byte[] input, byte[] output) { }
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC3575C Offset: 0xC3575C VA: 0xC3575C
public abstract class RIPEMD160 : HashAlgorithm // TypeDefIndex: 750
{
	// Methods

	// RVA: 0xE40ACC Offset: 0xE40ACC VA: 0xE40ACC
	protected void .ctor() { }

	// RVA: 0xE40AFC Offset: 0xE40AFC VA: 0xE40AFC
	public static RIPEMD160 Create() { }

	// RVA: 0xE40B44 Offset: 0xE40B44 VA: 0xE40B44
	public static RIPEMD160 Create(string hashName) { }
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC35770 Offset: 0xC35770 VA: 0xC35770
public class RIPEMD160Managed : RIPEMD160 // TypeDefIndex: 751
{
	// Fields
	private const int BLOCK_SIZE_BYTES = 64;
	private byte[] _ProcessingBuffer; // 0x28
	private uint[] _X; // 0x30
	private uint[] _HashValue; // 0x38
	private ulong _Length; // 0x40
	private int _ProcessingBufferCount; // 0x48

	// Methods

	// RVA: 0xE40C38 Offset: 0xE40C38 VA: 0xE40C38
	public void .ctor() { }

	// RVA: 0xE40CE0 Offset: 0xE40CE0 VA: 0xE40CE0 Slot: 17
	public override void Initialize() { }

	// RVA: 0xE40E5C Offset: 0xE40E5C VA: 0xE40E5C Slot: 14
	protected override void HashCore(byte[] rgb, int ibStart, int cbSize) { }

	// RVA: 0xE41160 Offset: 0xE41160 VA: 0xE41160 Slot: 15
	protected override byte[] HashFinal() { }

	// RVA: 0xE414BC Offset: 0xE414BC VA: 0xE414BC Slot: 1
	protected override void Finalize() { }

	// RVA: 0xE40F74 Offset: 0xE40F74 VA: 0xE40F74
	private void ProcessBlock(byte[] buffer, int offset) { }

	// RVA: 0xE41540 Offset: 0xE41540 VA: 0xE41540
	private void Compress() { }

	// RVA: 0xE412D0 Offset: 0xE412D0 VA: 0xE412D0
	private void CompressFinal(ulong length) { }

	// RVA: 0xE4598C Offset: 0xE4598C VA: 0xE4598C
	private uint ROL(uint x, int n) { }

	// RVA: 0xE4599C Offset: 0xE4599C VA: 0xE4599C
	private uint F(uint x, uint y, uint z) { }

	// RVA: 0xE459A8 Offset: 0xE459A8 VA: 0xE459A8
	private uint G(uint x, uint y, uint z) { }

	// RVA: 0xE459B8 Offset: 0xE459B8 VA: 0xE459B8
	private uint H(uint x, uint y, uint z) { }

	// RVA: 0xE459C4 Offset: 0xE459C4 VA: 0xE459C4
	private uint I(uint x, uint y, uint z) { }

	// RVA: 0xE459D4 Offset: 0xE459D4 VA: 0xE459D4
	private uint J(uint x, uint y, uint z) { }

	// RVA: 0xE456C4 Offset: 0xE456C4 VA: 0xE456C4
	private void FF(ref uint a, uint b, ref uint c, uint d, uint e, uint x, int s) { }

	// RVA: 0xE45700 Offset: 0xE45700 VA: 0xE45700
	private void GG(ref uint a, uint b, ref uint c, uint d, uint e, uint x, int s) { }

	// RVA: 0xE4574C Offset: 0xE4574C VA: 0xE4574C
	private void HH(ref uint a, uint b, ref uint c, uint d, uint e, uint x, int s) { }

	// RVA: 0xE45794 Offset: 0xE45794 VA: 0xE45794
	private void II(ref uint a, uint b, ref uint c, uint d, uint e, uint x, int s) { }

	// RVA: 0xE457E0 Offset: 0xE457E0 VA: 0xE457E0
	private void JJ(ref uint a, uint b, ref uint c, uint d, uint e, uint x, int s) { }

	// RVA: 0xE45950 Offset: 0xE45950 VA: 0xE45950
	private void FFF(ref uint a, uint b, ref uint c, uint d, uint e, uint x, int s) { }

	// RVA: 0xE45904 Offset: 0xE45904 VA: 0xE45904
	private void GGG(ref uint a, uint b, ref uint c, uint d, uint e, uint x, int s) { }

	// RVA: 0xE458BC Offset: 0xE458BC VA: 0xE458BC
	private void HHH(ref uint a, uint b, ref uint c, uint d, uint e, uint x, int s) { }

	// RVA: 0xE45870 Offset: 0xE45870 VA: 0xE45870
	private void III(ref uint a, uint b, ref uint c, uint d, uint e, uint x, int s) { }

	// RVA: 0xE45828 Offset: 0xE45828 VA: 0xE45828
	private void JJJ(ref uint a, uint b, ref uint c, uint d, uint e, uint x, int s) { }
}

// Namespace: System.Security.Cryptography
public sealed class RNGCryptoServiceProvider : RandomNumberGenerator // TypeDefIndex: 752
{
	// Fields
	private static object _lock; // 0x0
	private IntPtr _handle; // 0x10

	// Methods

	// RVA: 0xE459E0 Offset: 0xE459E0 VA: 0xE459E0
	public void .ctor() { }

	// RVA: 0xE45B14 Offset: 0xE45B14 VA: 0xE45B14
	private static void .cctor() { }

	// RVA: 0xE45A68 Offset: 0xE45A68 VA: 0xE45A68
	private void Check() { }

	// RVA: 0xE45B88 Offset: 0xE45B88 VA: 0xE45B88
	private static bool RngOpen() { }

	// RVA: 0xE45A64 Offset: 0xE45A64 VA: 0xE45A64
	private static IntPtr RngInitialize(byte[] seed) { }

	// RVA: 0xE45B8C Offset: 0xE45B8C VA: 0xE45B8C
	private static IntPtr RngGetBytes(IntPtr handle, byte[] data) { }

	// RVA: 0xE45B90 Offset: 0xE45B90 VA: 0xE45B90
	private static void RngClose(IntPtr handle) { }

	// RVA: 0xE45B94 Offset: 0xE45B94 VA: 0xE45B94 Slot: 4
	public override void GetBytes(byte[] data) { }

	// RVA: 0xE45D28 Offset: 0xE45D28 VA: 0xE45D28 Slot: 5
	public override void GetNonZeroBytes(byte[] data) { }

	// RVA: 0xE45EE4 Offset: 0xE45EE4 VA: 0xE45EE4 Slot: 1
	protected override void Finalize() { }
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC35784 Offset: 0xC35784 VA: 0xC35784
public abstract class RSA : AsymmetricAlgorithm // TypeDefIndex: 753
{
	// Methods

	// RVA: 0xE45FC0 Offset: 0xE45FC0 VA: 0xE45FC0
	protected void .ctor() { }

	// RVA: 0xE45FC8 Offset: 0xE45FC8 VA: 0xE45FC8
	public static RSA Create() { }

	// RVA: 0xE46010 Offset: 0xE46010 VA: 0xE46010
	public static RSA Create(string algName) { }

	// RVA: -1 Offset: -1 Slot: 13
	public abstract byte[] EncryptValue(byte[] rgb);

	// RVA: -1 Offset: -1 Slot: 14
	public abstract byte[] DecryptValue(byte[] rgb);

	// RVA: -1 Offset: -1 Slot: 15
	public abstract RSAParameters ExportParameters(bool includePrivateParameters);

	// RVA: -1 Offset: -1 Slot: 16
	public abstract void ImportParameters(RSAParameters parameters);

	// RVA: 0xE46104 Offset: 0xE46104 VA: 0xE46104
	internal void ZeroizePrivateKey(RSAParameters parameters) { }

	// RVA: 0xE461B8 Offset: 0xE461B8 VA: 0xE461B8 Slot: 11
	public override void FromXmlString(string xmlString) { }

	// RVA: 0xE465F4 Offset: 0xE465F4 VA: 0xE465F4 Slot: 12
	public override string ToXmlString(bool includePrivateParameters) { }
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC35798 Offset: 0xC35798 VA: 0xC35798
public sealed class RSACryptoServiceProvider : RSA, ICspAsymmetricAlgorithm // TypeDefIndex: 754
{
	// Fields
	private const int PROV_RSA_FULL = 1;
	private KeyPairPersistence store; // 0x20
	private bool persistKey; // 0x28
	private bool persisted; // 0x29
	private bool privateKeyExportable; // 0x2A
	private bool m_disposed; // 0x2B
	private RSAManaged rsa; // 0x30
	private static bool useMachineKeyStore; // 0x0
	[CompilerGeneratedAttribute] // RVA: 0xC377D8 Offset: 0xC377D8 VA: 0xC377D8
	private static Dictionary<string, int> <>f__switch$map29; // 0x8

	// Properties
	public static bool UseMachineKeyStore { get; set; }
	public override string KeyExchangeAlgorithm { get; }
	public override int KeySize { get; }
	public bool PersistKeyInCsp { get; set; }
	[ComVisibleAttribute] // RVA: 0xC3B404 Offset: 0xC3B404 VA: 0xC3B404
	public bool PublicOnly { get; }
	public override string SignatureAlgorithm { get; }
	[MonoTODOAttribute] // RVA: 0xC3B418 Offset: 0xC3B418 VA: 0xC3B418
	[ComVisibleAttribute] // RVA: 0xC3B418 Offset: 0xC3B418 VA: 0xC3B418
	public CspKeyContainerInfo CspKeyContainerInfo { get; }

	// Methods

	// RVA: 0xE46CFC Offset: 0xE46CFC VA: 0xE46CFC
	public void .ctor() { }

	// RVA: 0xE47034 Offset: 0xE47034 VA: 0xE47034
	public void .ctor(CspParameters parameters) { }

	// RVA: 0xE47070 Offset: 0xE47070 VA: 0xE47070
	public void .ctor(int dwKeySize) { }

	// RVA: 0xE470AC Offset: 0xE470AC VA: 0xE470AC
	public void .ctor(int dwKeySize, CspParameters parameters) { }

	// RVA: 0xE470F4 Offset: 0xE470F4 VA: 0xE470F4
	private static void .cctor() { }

	// RVA: 0xE46D34 Offset: 0xE46D34 VA: 0xE46D34
	private void Common(int dwKeySize, CspParameters p) { }

	// RVA: 0xE47118 Offset: 0xE47118 VA: 0xE47118
	public static bool get_UseMachineKeyStore() { }

	// RVA: 0xE47180 Offset: 0xE47180 VA: 0xE47180
	public static void set_UseMachineKeyStore(bool value) { }

	// RVA: 0xE471F0 Offset: 0xE471F0 VA: 0xE471F0 Slot: 1
	protected override void Finalize() { }

	// RVA: 0xE472D0 Offset: 0xE472D0 VA: 0xE472D0 Slot: 5
	public override string get_KeyExchangeAlgorithm() { }

	// RVA: 0xE470F8 Offset: 0xE470F8 VA: 0xE470F8 Slot: 6
	public override int get_KeySize() { }

	// RVA: 0xE47318 Offset: 0xE47318 VA: 0xE47318
	public bool get_PersistKeyInCsp() { }

	// RVA: 0xE47320 Offset: 0xE47320 VA: 0xE47320
	public void set_PersistKeyInCsp(bool value) { }

	// RVA: 0xE473E4 Offset: 0xE473E4 VA: 0xE473E4
	public bool get_PublicOnly() { }

	// RVA: 0xE47414 Offset: 0xE47414 VA: 0xE47414 Slot: 9
	public override string get_SignatureAlgorithm() { }

	// RVA: 0xE4745C Offset: 0xE4745C VA: 0xE4745C
	public byte[] Decrypt(byte[] rgb, bool fOAEP) { }

	// RVA: 0xE475C8 Offset: 0xE475C8 VA: 0xE475C8 Slot: 14
	public override byte[] DecryptValue(byte[] rgb) { }

	// RVA: 0xE4769C Offset: 0xE4769C VA: 0xE4769C
	public byte[] Encrypt(byte[] rgb, bool fOAEP) { }

	// RVA: 0xE477D8 Offset: 0xE477D8 VA: 0xE477D8 Slot: 13
	public override byte[] EncryptValue(byte[] rgb) { }

	// RVA: 0xE47814 Offset: 0xE47814 VA: 0xE47814 Slot: 15
	public override RSAParameters ExportParameters(bool includePrivateParameters) { }

	// RVA: 0xE478DC Offset: 0xE478DC VA: 0xE478DC Slot: 16
	public override void ImportParameters(RSAParameters parameters) { }

	// RVA: 0xE47954 Offset: 0xE47954 VA: 0xE47954
	private HashAlgorithm GetHash(object halg) { }

	// RVA: 0xE47B20 Offset: 0xE47B20 VA: 0xE47B20
	public byte[] SignData(byte[] buffer, object halg) { }

	// RVA: 0xE47C8C Offset: 0xE47C8C VA: 0xE47C8C
	public byte[] SignData(Stream inputStream, object halg) { }

	// RVA: 0xE47BCC Offset: 0xE47BCC VA: 0xE47BCC
	public byte[] SignData(byte[] buffer, int offset, int count, object halg) { }

	// RVA: 0xE47D34 Offset: 0xE47D34 VA: 0xE47D34
	private string GetHashNameFromOID(string oid) { }

	// RVA: 0xE47F74 Offset: 0xE47F74 VA: 0xE47F74
	public byte[] SignHash(byte[] rgbHash, string str) { }

	// RVA: 0xE48064 Offset: 0xE48064 VA: 0xE48064
	public bool VerifyData(byte[] buffer, object halg, byte[] signature) { }

	// RVA: 0xE48184 Offset: 0xE48184 VA: 0xE48184
	public bool VerifyHash(byte[] rgbHash, string str, byte[] rgbSignature) { }

	// RVA: 0xE47268 Offset: 0xE47268 VA: 0xE47268 Slot: 10
	protected override void Dispose(bool disposing) { }

	// RVA: 0xE47334 Offset: 0xE47334 VA: 0xE47334
	private void OnKeyGenerated(object sender, EventArgs e) { }

	// RVA: 0xE482A4 Offset: 0xE482A4 VA: 0xE482A4 Slot: 19
	public CspKeyContainerInfo get_CspKeyContainerInfo() { }

	[ComVisibleAttribute] // RVA: 0xC39804 Offset: 0xC39804 VA: 0xC39804
	// RVA: 0xE482AC Offset: 0xE482AC VA: 0xE482AC Slot: 17
	public byte[] ExportCspBlob(bool includePrivateParameters) { }

	[ComVisibleAttribute] // RVA: 0xC39818 Offset: 0xC39818 VA: 0xC39818
	// RVA: 0xE48314 Offset: 0xE48314 VA: 0xE48314 Slot: 18
	public void ImportCspBlob(byte[] keyBlob) { }
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC357AC Offset: 0xC357AC VA: 0xC357AC
public class RSAOAEPKeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter // TypeDefIndex: 755
{
	// Fields
	private RSA rsa; // 0x10

	// Properties
	public override string Parameters { get; set; }

	// Methods

	// RVA: 0xE48510 Offset: 0xE48510 VA: 0xE48510
	public void .ctor() { }

	// RVA: 0xE47558 Offset: 0xE47558 VA: 0xE47558
	public void .ctor(AsymmetricAlgorithm key) { }

	// RVA: 0xE48518 Offset: 0xE48518 VA: 0xE48518 Slot: 4
	public override string get_Parameters() { }

	// RVA: 0xE48520 Offset: 0xE48520 VA: 0xE48520 Slot: 5
	public override void set_Parameters(string value) { }

	// RVA: 0xE48524 Offset: 0xE48524 VA: 0xE48524 Slot: 6
	public override byte[] DecryptKeyExchange(byte[] rgbData) { }

	// RVA: 0xE4865C Offset: 0xE4865C VA: 0xE4865C Slot: 7
	public override void SetKey(AsymmetricAlgorithm key) { }
}

// Namespace: System.Security.Cryptography
[ComVisibleAttribute] // RVA: 0xC357C0 Offset: 0xC357C0 VA: 0xC357C0
public class RSAOAEPKeyExchangeFormatter : AsymmetricKeyExchangeFormatter // TypeDefIndex: 756
{
	// Fields
	private RSA rsa; // 0x10
	private RandomNumberGenerator random; // 0x18
	private byte[] param; // 0x20

	// Properties
	public byte[] Parameter { get; set; }
	public override string Parameters { get; }
	public RandomNumberGenerator Rng { get; set; }

	// Methods

	// RVA: 0xE4872C Offset: 0xE4872C VA: 0xE4872C
	public void .ctor() { }

	// RVA: 0xE47770 Offset: 0xE47770 VA: 0xE47770
	public void .ctor(AsymmetricAlgorithm key) { }

	// RVA: 0xE48754 Offset: 0xE48754 VA: 0xE48754
	public byte[] get_Parameter() { }

	// RVA: 0xE4875C Offset: 0xE4875C VA: 0xE4875C
	public void set_Parameter(byte[] value) { }

	// RVA: 0xE48764 Offset: 0xE48764 VA: 0xE48764 Slot: 4
	public override string get_Parameters() { }
