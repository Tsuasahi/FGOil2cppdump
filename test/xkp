	public virtual string AlgorithmName { get; }

	// Methods

	// RVA: 0x2595888 Offset: 0x2595888 VA: 0x2595888
	public void .ctor() { }

	// RVA: 0x2595908 Offset: 0x2595908 VA: 0x2595908 Slot: 8
	public virtual void Init(bool forWrapping, ICipherParameters parameters) { }

	// RVA: 0x2595B84 Offset: 0x2595B84 VA: 0x2595B84 Slot: 9
	public virtual string get_AlgorithmName() { }

	// RVA: 0x2595BCC Offset: 0x2595BCC VA: 0x2595BCC Slot: 10
	public virtual byte[] Wrap(byte[] input, int inOff, int length) { }

	// RVA: 0x2596310 Offset: 0x2596310 VA: 0x2596310 Slot: 11
	public virtual byte[] Unwrap(byte[] input, int inOff, int length) { }

	// RVA: 0x2596164 Offset: 0x2596164 VA: 0x2596164
	private byte[] CalculateCmsKeyChecksum(byte[] key) { }

	// RVA: 0x25969F0 Offset: 0x25969F0 VA: 0x25969F0
	private bool CheckCmsKeyChecksum(byte[] key, byte[] checksum) { }

	// RVA: 0x2596A18 Offset: 0x2596A18 VA: 0x2596A18
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class RC4Engine : IStreamCipher // TypeDefIndex: 4715
{
	// Fields
	private static readonly int STATE_LENGTH; // 0x0
	private byte[] engineState; // 0x10
	private int x; // 0x18
	private int y; // 0x1C
	private byte[] workingKey; // 0x20

	// Properties
	public virtual string AlgorithmName { get; }

	// Methods

	// RVA: 0x2596A94 Offset: 0x2596A94 VA: 0x2596A94
	public void .ctor() { }

	// RVA: 0x2596A9C Offset: 0x2596A9C VA: 0x2596A9C Slot: 9
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x2596EA0 Offset: 0x2596EA0 VA: 0x2596EA0 Slot: 10
	public virtual string get_AlgorithmName() { }

	// RVA: 0x2596EE8 Offset: 0x2596EE8 VA: 0x2596EE8 Slot: 11
	public virtual byte ReturnByte(byte input) { }

	// RVA: 0x25970D8 Offset: 0x25970D8 VA: 0x25970D8 Slot: 12
	public virtual void ProcessBytes(byte[] input, int inOff, int length, byte[] output, int outOff) { }

	// RVA: 0x25973E8 Offset: 0x25973E8 VA: 0x25973E8 Slot: 13
	public virtual void Reset() { }

	// RVA: 0x2596BF0 Offset: 0x2596BF0 VA: 0x2596BF0
	private void SetKey(byte[] keyBytes) { }

	// RVA: 0x25973F0 Offset: 0x25973F0 VA: 0x25973F0
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class RC532Engine : IBlockCipher // TypeDefIndex: 4716
{
	// Fields
	private int _noRounds; // 0x10
	private int[] _S; // 0x18
	private static readonly int P32; // 0x0
	private static readonly int Q32; // 0x4
	private bool forEncryption; // 0x20

	// Properties
	public virtual string AlgorithmName { get; }
	public virtual bool IsPartialBlockOkay { get; }

	// Methods

	// RVA: 0x2597444 Offset: 0x2597444 VA: 0x2597444
	public void .ctor() { }

	// RVA: 0x2597470 Offset: 0x2597470 VA: 0x2597470 Slot: 10
	public virtual string get_AlgorithmName() { }

	// RVA: 0x25974B8 Offset: 0x25974B8 VA: 0x25974B8 Slot: 11
	public virtual bool get_IsPartialBlockOkay() { }

	// RVA: 0x25974C0 Offset: 0x25974C0 VA: 0x25974C0 Slot: 12
	public virtual int GetBlockSize() { }

	// RVA: 0x25974C8 Offset: 0x25974C8 VA: 0x25974C8 Slot: 13
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x2597B8C Offset: 0x2597B8C VA: 0x2597B8C Slot: 14
	public virtual int ProcessBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x2597EEC Offset: 0x2597EEC VA: 0x2597EEC Slot: 15
	public virtual void Reset() { }

	// RVA: 0x25977D8 Offset: 0x25977D8 VA: 0x25977D8
	private void SetKey(byte[] key) { }

	// RVA: 0x2597BB4 Offset: 0x2597BB4 VA: 0x2597BB4
	private int EncryptBlock(byte[] input, int inOff, byte[] outBytes, int outOff) { }

	// RVA: 0x2597D64 Offset: 0x2597D64 VA: 0x2597D64
	private int DecryptBlock(byte[] input, int inOff, byte[] outBytes, int outOff) { }

	// RVA: 0x2597EF0 Offset: 0x2597EF0 VA: 0x2597EF0
	private int RotateLeft(int x, int y) { }

	// RVA: 0x25980E8 Offset: 0x25980E8 VA: 0x25980E8
	private int RotateRight(int x, int y) { }

	// RVA: 0x2597F00 Offset: 0x2597F00 VA: 0x2597F00
	private int BytesToWord(byte[] src, int srcOff) { }

	// RVA: 0x2597FF8 Offset: 0x2597FF8 VA: 0x2597FF8
	private void WordToBytes(int word, byte[] dst, int dstOff) { }

	// RVA: 0x25980F4 Offset: 0x25980F4 VA: 0x25980F4
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class RC564Engine : IBlockCipher // TypeDefIndex: 4717
{
	// Fields
	private static readonly int wordSize; // 0x0
	private static readonly int bytesPerWord; // 0x4
	private int _noRounds; // 0x10
	private long[] _S; // 0x18
	private static readonly long P64; // 0x8
	private static readonly long Q64; // 0x10
	private bool forEncryption; // 0x20

	// Properties
	public virtual string AlgorithmName { get; }
	public virtual bool IsPartialBlockOkay { get; }

	// Methods

	// RVA: 0x241D80C Offset: 0x241D80C VA: 0x241D80C
	public void .ctor() { }

	// RVA: 0x241D838 Offset: 0x241D838 VA: 0x241D838 Slot: 10
	public virtual string get_AlgorithmName() { }

	// RVA: 0x241D880 Offset: 0x241D880 VA: 0x241D880 Slot: 11
	public virtual bool get_IsPartialBlockOkay() { }

	// RVA: 0x241D888 Offset: 0x241D888 VA: 0x241D888 Slot: 12
	public virtual int GetBlockSize() { }

	// RVA: 0x241D8F4 Offset: 0x241D8F4 VA: 0x241D8F4 Slot: 13
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x241DF38 Offset: 0x241DF38 VA: 0x241DF38 Slot: 14
	public virtual int ProcessBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x241E394 Offset: 0x241E394 VA: 0x241E394 Slot: 15
	public virtual void Reset() { }

	// RVA: 0x241DB38 Offset: 0x241DB38 VA: 0x241DB38
	private void SetKey(byte[] key) { }

	// RVA: 0x241DF48 Offset: 0x241DF48 VA: 0x241DF48
	private int EncryptBlock(byte[] input, int inOff, byte[] outBytes, int outOff) { }

	// RVA: 0x241E180 Offset: 0x241E180 VA: 0x241E180
	private int DecryptBlock(byte[] input, int inOff, byte[] outBytes, int outOff) { }

	// RVA: 0x241E398 Offset: 0x241E398 VA: 0x241E398
	private long RotateLeft(long x, long y) { }

	// RVA: 0x241E5E0 Offset: 0x241E5E0 VA: 0x241E5E0
	private long RotateRight(long x, long y) { }

	// RVA: 0x241E430 Offset: 0x241E430 VA: 0x241E430
	private long BytesToWord(byte[] src, int srcOff) { }

	// RVA: 0x241E50C Offset: 0x241E50C VA: 0x241E50C
	private void WordToBytes(long word, byte[] dst, int dstOff) { }

	// RVA: 0x241E678 Offset: 0x241E678 VA: 0x241E678
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class RC6Engine : IBlockCipher // TypeDefIndex: 4718
{
	// Fields
	private static readonly int wordSize; // 0x0
	private static readonly int bytesPerWord; // 0x4
	private static readonly int _noRounds; // 0x8
	private int[] _S; // 0x10
	private static readonly int P32; // 0xC
	private static readonly int Q32; // 0x10
	private static readonly int LGW; // 0x14
	private bool forEncryption; // 0x18

	// Properties
	public virtual string AlgorithmName { get; }
	public virtual bool IsPartialBlockOkay { get; }

	// Methods

	// RVA: 0x241E720 Offset: 0x241E720 VA: 0x241E720
	public void .ctor() { }

	// RVA: 0x241E728 Offset: 0x241E728 VA: 0x241E728 Slot: 10
	public virtual string get_AlgorithmName() { }

	// RVA: 0x241E770 Offset: 0x241E770 VA: 0x241E770 Slot: 11
	public virtual bool get_IsPartialBlockOkay() { }

	// RVA: 0x241E778 Offset: 0x241E778 VA: 0x241E778 Slot: 12
	public virtual int GetBlockSize() { }

	// RVA: 0x241E7E4 Offset: 0x241E7E4 VA: 0x241E7E4 Slot: 13
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x241EE00 Offset: 0x241EE00 VA: 0x241EE00 Slot: 14
	public virtual int ProcessBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x241F78C Offset: 0x241F78C VA: 0x241F78C Slot: 15
	public virtual void Reset() { }

	// RVA: 0x241E9BC Offset: 0x241E9BC VA: 0x241E9BC
	private void SetKey(byte[] key) { }

	// RVA: 0x241EF44 Offset: 0x241EF44 VA: 0x241EF44
	private int EncryptBlock(byte[] input, int inOff, byte[] outBytes, int outOff) { }

	// RVA: 0x241F358 Offset: 0x241F358 VA: 0x241F358
	private int DecryptBlock(byte[] input, int inOff, byte[] outBytes, int outOff) { }

	// RVA: 0x241F790 Offset: 0x241F790 VA: 0x241F790
	private int RotateLeft(int x, int y) { }

	// RVA: 0x241F9D8 Offset: 0x241F9D8 VA: 0x241F9D8
	private int RotateRight(int x, int y) { }

	// RVA: 0x241F828 Offset: 0x241F828 VA: 0x241F828
	private int BytesToWord(byte[] src, int srcOff) { }

	// RVA: 0x241F904 Offset: 0x241F904 VA: 0x241F904
	private void WordToBytes(int word, byte[] dst, int dstOff) { }

	// RVA: 0x241FA70 Offset: 0x241FA70 VA: 0x241FA70
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class Rfc3211WrapEngine : IWrapper // TypeDefIndex: 4719
{
	// Fields
	private CbcBlockCipher engine; // 0x10
	private ParametersWithIV param; // 0x18
	private bool forWrapping; // 0x20
	private SecureRandom rand; // 0x28

	// Properties
	public virtual string AlgorithmName { get; }

	// Methods

	// RVA: 0x241FB20 Offset: 0x241FB20 VA: 0x241FB20
	public void .ctor(IBlockCipher engine) { }

	// RVA: 0x241FB9C Offset: 0x241FB9C VA: 0x241FB9C Slot: 8
	public virtual void Init(bool forWrapping, ICipherParameters param) { }

	// RVA: 0x241FD70 Offset: 0x241FD70 VA: 0x241FD70 Slot: 9
	public virtual string get_AlgorithmName() { }

	// RVA: 0x241FE7C Offset: 0x241FE7C VA: 0x241FE7C Slot: 10
	public virtual byte[] Wrap(byte[] inBytes, int inOff, int inLen) { }

	// RVA: 0x24201BC Offset: 0x24201BC VA: 0x24201BC Slot: 11
	public virtual byte[] Unwrap(byte[] inBytes, int inOff, int inLen) { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class Rfc3394WrapEngine : IWrapper // TypeDefIndex: 4720
{
	// Fields
	private readonly IBlockCipher engine; // 0x10
	private KeyParameter param; // 0x18
	private bool forWrapping; // 0x20
	private byte[] iv; // 0x28

	// Properties
	public virtual string AlgorithmName { get; }

	// Methods

	// RVA: 0x2420664 Offset: 0x2420664 VA: 0x2420664
	public void .ctor(IBlockCipher engine) { }

	// RVA: 0x24206F0 Offset: 0x24206F0 VA: 0x24206F0 Slot: 8
	public virtual void Init(bool forWrapping, ICipherParameters parameters) { }

	// RVA: 0x2420904 Offset: 0x2420904 VA: 0x2420904 Slot: 9
	public virtual string get_AlgorithmName() { }

	// RVA: 0x24209B8 Offset: 0x24209B8 VA: 0x24209B8 Slot: 10
	public virtual byte[] Wrap(byte[] input, int inOff, int inLen) { }

	// RVA: 0x2420DCC Offset: 0x2420DCC VA: 0x2420DCC Slot: 11
	public virtual byte[] Unwrap(byte[] input, int inOff, int inLen) { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class RijndaelEngine : IBlockCipher // TypeDefIndex: 4721
{
	// Fields
	private static readonly int MAXROUNDS; // 0x0
	private static readonly int MAXKC; // 0x4
	private static readonly byte[] Logtable; // 0x8
	private static readonly byte[] Alogtable; // 0x10
	private static readonly byte[] S; // 0x18
	private static readonly byte[] Si; // 0x20
	private static readonly byte[] rcon; // 0x28
	private static readonly byte[][] shifts0; // 0x30
	private static readonly byte[][] shifts1; // 0x38
	private int BC; // 0x10
	private long BC_MASK; // 0x18
	private int ROUNDS; // 0x20
	private int blockBits; // 0x24
	private long[][] workingKey; // 0x28
	private long A0; // 0x30
	private long A1; // 0x38
	private long A2; // 0x40
	private long A3; // 0x48
	private bool forEncryption; // 0x50
	private byte[] shifts0SC; // 0x58
	private byte[] shifts1SC; // 0x60

	// Properties
	public virtual string AlgorithmName { get; }
	public virtual bool IsPartialBlockOkay { get; }

	// Methods

	// RVA: 0x2421260 Offset: 0x2421260 VA: 0x2421260
	public void .ctor() { }

	// RVA: 0x2421268 Offset: 0x2421268 VA: 0x2421268
	public void .ctor(int blockBits) { }

	// RVA: 0x2421670 Offset: 0x2421670 VA: 0x2421670
	private byte Mul0x2(int b) { }

	// RVA: 0x2421758 Offset: 0x2421758 VA: 0x2421758
	private byte Mul0x3(int b) { }

	// RVA: 0x2421840 Offset: 0x2421840 VA: 0x2421840
	private byte Mul0x9(int b) { }

	// RVA: 0x24218F0 Offset: 0x24218F0 VA: 0x24218F0
	private byte Mul0xb(int b) { }

	// RVA: 0x24219A0 Offset: 0x24219A0 VA: 0x24219A0
	private byte Mul0xd(int b) { }

	// RVA: 0x2421A50 Offset: 0x2421A50 VA: 0x2421A50
	private byte Mul0xe(int b) { }

	// RVA: 0x2421B00 Offset: 0x2421B00 VA: 0x2421B00
	private void KeyAddition(long[] rk) { }

	// RVA: 0x2421BE0 Offset: 0x2421BE0 VA: 0x2421BE0
	private long Shift(long r, int shift) { }

	// RVA: 0x2421C14 Offset: 0x2421C14 VA: 0x2421C14
	private void ShiftRow(byte[] shiftsSC) { }

	// RVA: 0x2421D50 Offset: 0x2421D50 VA: 0x2421D50
	private long ApplyS(long r, byte[] box) { }

	// RVA: 0x2421DF8 Offset: 0x2421DF8 VA: 0x2421DF8
	private void Substitution(byte[] box) { }

	// RVA: 0x2421E68 Offset: 0x2421E68 VA: 0x2421E68
	private void MixColumn() { }

	// RVA: 0x242201C Offset: 0x242201C VA: 0x242201C
	private void InvMixColumn() { }

	// RVA: 0x24223A0 Offset: 0x24223A0 VA: 0x24223A0
	private long[][] GenerateWorkingKey(byte[] key) { }

	// RVA: 0x2422F2C Offset: 0x2422F2C VA: 0x2422F2C Slot: 10
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x24231B8 Offset: 0x24231B8 VA: 0x24231B8 Slot: 11
	public virtual string get_AlgorithmName() { }

	// RVA: 0x2423200 Offset: 0x2423200 VA: 0x2423200 Slot: 12
	public virtual bool get_IsPartialBlockOkay() { }

	// RVA: 0x2423208 Offset: 0x2423208 VA: 0x2423208 Slot: 13
	public virtual int GetBlockSize() { }

	// RVA: 0x242321C Offset: 0x242321C VA: 0x242321C Slot: 14
	public virtual int ProcessBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x24239D0 Offset: 0x24239D0 VA: 0x24239D0 Slot: 15
	public virtual void Reset() { }

	// RVA: 0x242336C Offset: 0x242336C VA: 0x242336C
	private void UnPackBlock(byte[] bytes, int off) { }

	// RVA: 0x2423884 Offset: 0x2423884 VA: 0x2423884
	private void PackBlock(byte[] bytes, int off) { }

	// RVA: 0x2423588 Offset: 0x2423588 VA: 0x2423588
	private void EncryptBlock(long[][] rk) { }

	// RVA: 0x2423710 Offset: 0x2423710 VA: 0x2423710
	private void DecryptBlock(long[][] rk) { }

	// RVA: 0x24239D4 Offset: 0x24239D4 VA: 0x24239D4
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class RsaBlindedEngine : IAsymmetricBlockCipher // TypeDefIndex: 4722
{
	// Fields
	private readonly RsaCoreEngine core; // 0x10
	private RsaKeyParameters key; // 0x18
	private SecureRandom random; // 0x20

	// Properties
	public virtual string AlgorithmName { get; }

	// Methods

	// RVA: 0x2423FD0 Offset: 0x2423FD0 VA: 0x2423FD0
	public void .ctor() { }

	// RVA: 0x2424040 Offset: 0x2424040 VA: 0x2424040 Slot: 9
	public virtual string get_AlgorithmName() { }

	// RVA: 0x2424088 Offset: 0x2424088 VA: 0x2424088 Slot: 10
	public virtual void Init(bool forEncryption, ICipherParameters param) { }

	// RVA: 0x2424278 Offset: 0x2424278 VA: 0x2424278 Slot: 11
	public virtual int GetInputBlockSize() { }

	// RVA: 0x24242AC Offset: 0x24242AC VA: 0x24242AC Slot: 12
	public virtual int GetOutputBlockSize() { }

	// RVA: 0x24242E0 Offset: 0x24242E0 VA: 0x24242E0 Slot: 13
	public virtual byte[] ProcessBlock(byte[] inBuf, int inOff, int inLen) { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
internal class RsaCoreEngine // TypeDefIndex: 4723
{
	// Fields
	private RsaKeyParameters key; // 0x10
	private bool forEncryption; // 0x18
	private int bitSize; // 0x1C

	// Methods

	// RVA: 0x2424038 Offset: 0x2424038 VA: 0x2424038
	public void .ctor() { }

	// RVA: 0x2424608 Offset: 0x2424608 VA: 0x2424608 Slot: 4
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x2424750 Offset: 0x2424750 VA: 0x2424750 Slot: 5
	public virtual int GetInputBlockSize() { }

	// RVA: 0x242477C Offset: 0x242477C VA: 0x242477C Slot: 6
	public virtual int GetOutputBlockSize() { }

	// RVA: 0x24247A8 Offset: 0x24247A8 VA: 0x24247A8 Slot: 7
	public virtual BigInteger ConvertInput(byte[] inBuf, int inOff, int inLen) { }

	// RVA: 0x24248D8 Offset: 0x24248D8 VA: 0x24248D8 Slot: 8
	public virtual byte[] ConvertOutput(BigInteger result) { }

	// RVA: 0x24249B8 Offset: 0x24249B8 VA: 0x24249B8 Slot: 9
	public virtual BigInteger ProcessBlock(BigInteger input) { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class Salsa20Engine : IStreamCipher // TypeDefIndex: 4724
{
	// Fields
	public static readonly int DEFAULT_ROUNDS; // 0x0
	private const int StateSize = 16;
	private static readonly uint[] TAU_SIGMA; // 0x8
	[ObsoleteAttribute] // RVA: 0xCB6068 Offset: 0xCB6068 VA: 0xCB6068
	protected static readonly byte[] sigma; // 0x10
	[ObsoleteAttribute] // RVA: 0xCB6078 Offset: 0xCB6078 VA: 0xCB6078
	protected static readonly byte[] tau; // 0x18
	protected int rounds; // 0x10
	private int index; // 0x14
	internal uint[] engineState; // 0x18
	internal uint[] x; // 0x20
	private byte[] keyStream; // 0x28
	private bool initialised; // 0x30
	private uint cW0; // 0x34
	private uint cW1; // 0x38
	private uint cW2; // 0x3C

	// Properties
	protected virtual int NonceSize { get; }
	public virtual string AlgorithmName { get; }

	// Methods

	// RVA: 0x2424C18 Offset: 0x2424C18 VA: 0x2424C18
	public void .ctor() { }

	// RVA: 0x2424C88 Offset: 0x2424C88 VA: 0x2424C88
	public void .ctor(int rounds) { }

	// RVA: 0x2424D74 Offset: 0x2424D74 VA: 0x2424D74
	internal void PackTauOrSigma(int keyLength, uint[] state, int stateOffset) { }

	// RVA: 0x2424FB8 Offset: 0x2424FB8 VA: 0x2424FB8 Slot: 9
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x2425470 Offset: 0x2425470 VA: 0x2425470 Slot: 10
	protected virtual int get_NonceSize() { }

	// RVA: 0x2425478 Offset: 0x2425478 VA: 0x2425478 Slot: 11
	public virtual string get_AlgorithmName() { }

	// RVA: 0x2425574 Offset: 0x2425574 VA: 0x2425574 Slot: 12
	public virtual byte ReturnByte(byte input) { }

	// RVA: 0x24256F0 Offset: 0x24256F0 VA: 0x24256F0 Slot: 13
	protected virtual void AdvanceCounter() { }

	// RVA: 0x2425780 Offset: 0x2425780 VA: 0x2425780 Slot: 14
	public virtual void ProcessBytes(byte[] inBytes, int inOff, int len, byte[] outBytes, int outOff) { }

	// RVA: 0x2425A78 Offset: 0x2425A78 VA: 0x2425A78 Slot: 15
	public virtual void Reset() { }

	// RVA: 0x2425AA0 Offset: 0x2425AA0 VA: 0x2425AA0 Slot: 16
	protected virtual void ResetCounter() { }

	// RVA: 0x2425B08 Offset: 0x2425B08 VA: 0x2425B08 Slot: 17
	protected virtual void SetKey(byte[] keyBytes, byte[] ivBytes) { }

	// RVA: 0x2425E5C Offset: 0x2425E5C VA: 0x2425E5C Slot: 18
	protected virtual void GenerateKeyStream(byte[] output) { }

	// RVA: 0x2425EF8 Offset: 0x2425EF8 VA: 0x2425EF8
	internal static void SalsaCore(int rounds, uint[] input, uint[] x) { }

	// RVA: 0x2426AF8 Offset: 0x2426AF8 VA: 0x2426AF8
	internal static uint R(uint x, int y) { }

	// RVA: 0x2425A94 Offset: 0x2425A94 VA: 0x2425A94
	private void ResetLimitCounter() { }

	// RVA: 0x24256B4 Offset: 0x24256B4 VA: 0x24256B4
	private bool LimitExceeded() { }

	// RVA: 0x2425A3C Offset: 0x2425A3C VA: 0x2425A3C
	private bool LimitExceeded(uint len) { }

	// RVA: 0x2426B08 Offset: 0x2426B08 VA: 0x2426B08
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class SeedEngine : IBlockCipher // TypeDefIndex: 4725
{
	// Fields
	private const int BlockSize = 16;
	private static readonly uint[] SS0; // 0x0
	private static readonly uint[] SS1; // 0x8
	private static readonly uint[] SS2; // 0x10
	private static readonly uint[] SS3; // 0x18
	private static readonly uint[] KC; // 0x20
	private int[] wKey; // 0x10
	private bool forEncryption; // 0x18

	// Properties
	public virtual string AlgorithmName { get; }
	public virtual bool IsPartialBlockOkay { get; }

	// Methods

	// RVA: 0x2426BCC Offset: 0x2426BCC VA: 0x2426BCC
	public void .ctor() { }

	// RVA: 0x2426BD4 Offset: 0x2426BD4 VA: 0x2426BD4 Slot: 10
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x2426F6C Offset: 0x2426F6C VA: 0x2426F6C Slot: 11
	public virtual string get_AlgorithmName() { }

	// RVA: 0x2426FB4 Offset: 0x2426FB4 VA: 0x2426FB4 Slot: 12
	public virtual bool get_IsPartialBlockOkay() { }

	// RVA: 0x2426FBC Offset: 0x2426FBC VA: 0x2426FBC Slot: 13
	public virtual int GetBlockSize() { }

	// RVA: 0x2426FC4 Offset: 0x2426FC4 VA: 0x2426FC4 Slot: 14
	public virtual int ProcessBlock(byte[] inBuf, int inOff, byte[] outBuf, int outOff) { }

	// RVA: 0x24273C4 Offset: 0x24273C4 VA: 0x24273C4 Slot: 15
	public virtual void Reset() { }

	// RVA: 0x2426D50 Offset: 0x2426D50 VA: 0x2426D50
	private int[] createWorkingKey(byte[] inKey) { }

	// RVA: 0x24273D0 Offset: 0x24273D0 VA: 0x24273D0
	private int extractW1(long lVal) { }

	// RVA: 0x24273C8 Offset: 0x24273C8 VA: 0x24273C8
	private int extractW0(long lVal) { }

	// RVA: 0x242755C Offset: 0x242755C VA: 0x242755C
	private long rotateLeft8(long x) { }

	// RVA: 0x2427554 Offset: 0x2427554 VA: 0x2427554
	private long rotateRight8(long x) { }

	// RVA: 0x2427248 Offset: 0x2427248 VA: 0x2427248
	private long bytesToLong(byte[] src, int srcOff) { }

	// RVA: 0x2427340 Offset: 0x2427340 VA: 0x2427340
	private void longToBytes(byte[] dest, int destOff, long value) { }

	// RVA: 0x24273D8 Offset: 0x24273D8 VA: 0x24273D8
	private int G(int x) { }

	// RVA: 0x24272D0 Offset: 0x24272D0 VA: 0x24272D0
	private long F(int ki0, int ki1, long r) { }

	// RVA: 0x24275A8 Offset: 0x24275A8 VA: 0x24275A8
	private int phaseCalc1(int r0, int ki0, int r1, int ki1) { }

	// RVA: 0x2427564 Offset: 0x2427564 VA: 0x2427564
	private int phaseCalc2(int r0, int ki0, int r1, int ki1) { }

	// RVA: 0x24275D4 Offset: 0x24275D4 VA: 0x24275D4
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class SeedWrapEngine : Rfc3394WrapEngine // TypeDefIndex: 4726
{
	// Methods

	// RVA: 0x2427718 Offset: 0x2427718 VA: 0x2427718
	public void .ctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public sealed class SerpentEngine : SerpentEngineBase // TypeDefIndex: 4727
{
	// Methods

	// RVA: 0x242777C Offset: 0x242777C VA: 0x242777C
	public void .ctor() { }

	// RVA: 0x24277EC Offset: 0x24277EC VA: 0x24277EC Slot: 15
	protected override int[] MakeWorkingKey(byte[] key) { }

	// RVA: 0x242A918 Offset: 0x242A918 VA: 0x242A918 Slot: 16
	protected override void EncryptBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x242D100 Offset: 0x242D100 VA: 0x242D100 Slot: 17
	protected override void DecryptBlock(byte[] input, int inOff, byte[] output, int outOff) { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public abstract class SerpentEngineBase : IBlockCipher // TypeDefIndex: 4728
{
	// Fields
	protected static readonly int BlockSize; // 0x0
	internal const int ROUNDS = 32;
	internal const int PHI = -1640531527;
	protected bool encrypting; // 0x10
	protected int[] wKey; // 0x18
	protected int X0; // 0x20
	protected int X1; // 0x24
	protected int X2; // 0x28
	protected int X3; // 0x2C

	// Properties
	public virtual string AlgorithmName { get; }
	public virtual bool IsPartialBlockOkay { get; }

	// Methods

	// RVA: 0x24277E4 Offset: 0x24277E4 VA: 0x24277E4
	protected void .ctor() { }

	// RVA: 0x242FD78 Offset: 0x242FD78 VA: 0x242FD78 Slot: 10
	public virtual void Init(bool encrypting, ICipherParameters parameters) { }

	// RVA: 0x242FFF4 Offset: 0x242FFF4 VA: 0x242FFF4 Slot: 11
	public virtual string get_AlgorithmName() { }

	// RVA: 0x243003C Offset: 0x243003C VA: 0x243003C Slot: 12
	public virtual bool get_IsPartialBlockOkay() { }

	// RVA: 0x2430044 Offset: 0x2430044 VA: 0x2430044 Slot: 13
	public virtual int GetBlockSize() { }

	// RVA: 0x24300AC Offset: 0x24300AC VA: 0x24300AC Slot: 8
	public int ProcessBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x2430274 Offset: 0x2430274 VA: 0x2430274 Slot: 14
	public virtual void Reset() { }

	// RVA: 0x242A6DC Offset: 0x242A6DC VA: 0x242A6DC
	protected static int RotateLeft(int x, int bits) { }

	// RVA: 0x2430278 Offset: 0x2430278 VA: 0x2430278
	private static int RotateRight(int x, int bits) { }

	// RVA: 0x242A7C4 Offset: 0x242A7C4 VA: 0x242A7C4
	protected void Sb0(int a, int b, int c, int d) { }

	// RVA: 0x242FD34 Offset: 0x242FD34 VA: 0x242FD34
	protected void Ib0(int a, int b, int c, int d) { }

	// RVA: 0x242A784 Offset: 0x242A784 VA: 0x242A784
	protected void Sb1(int a, int b, int c, int d) { }

	// RVA: 0x242FCF4 Offset: 0x242FCF4 VA: 0x242FCF4
	protected void Ib1(int a, int b, int c, int d) { }

	// RVA: 0x242A738 Offset: 0x242A738 VA: 0x242A738
	protected void Sb2(int a, int b, int c, int d) { }

	// RVA: 0x242FCB0 Offset: 0x242FCB0 VA: 0x242FCB0
	protected void Ib2(int a, int b, int c, int d) { }

	// RVA: 0x242A6EC Offset: 0x242A6EC VA: 0x242A6EC
	protected void Sb3(int a, int b, int c, int d) { }

	// RVA: 0x242FC68 Offset: 0x242FC68 VA: 0x242FC68
	protected void Ib3(int a, int b, int c, int d) { }

	// RVA: 0x242A8D4 Offset: 0x242A8D4 VA: 0x242A8D4
	protected void Sb4(int a, int b, int c, int d) { }

	// RVA: 0x242FC24 Offset: 0x242FC24 VA: 0x242FC24
	protected void Ib4(int a, int b, int c, int d) { }

	// RVA: 0x242A88C Offset: 0x242A88C VA: 0x242A88C
	protected void Sb5(int a, int b, int c, int d) { }

	// RVA: 0x242FBDC Offset: 0x242FBDC VA: 0x242FBDC
	protected void Ib5(int a, int b, int c, int d) { }

	// RVA: 0x242A84C Offset: 0x242A84C VA: 0x242A84C
	protected void Sb6(int a, int b, int c, int d) { }

	// RVA: 0x242FB98 Offset: 0x242FB98 VA: 0x242FB98
	protected void Ib6(int a, int b, int c, int d) { }

	// RVA: 0x242A804 Offset: 0x242A804 VA: 0x242A804
	protected void Sb7(int a, int b, int c, int d) { }

	// RVA: 0x242FAB0 Offset: 0x242FAB0 VA: 0x242FAB0
	protected void Ib7(int a, int b, int c, int d) { }

	// RVA: 0x242D054 Offset: 0x242D054 VA: 0x242D054
	protected void LT() { }

	// RVA: 0x242FAFC Offset: 0x242FAFC VA: 0x242FAFC
	protected void InverseLT() { }

	// RVA: -1 Offset: -1 Slot: 15
	protected abstract int[] MakeWorkingKey(byte[] key);

	// RVA: -1 Offset: -1 Slot: 16
	protected abstract void EncryptBlock(byte[] input, int inOff, byte[] output, int outOff);

	// RVA: -1 Offset: -1 Slot: 17
	protected abstract void DecryptBlock(byte[] input, int inOff, byte[] output, int outOff);

	// RVA: 0x2430284 Offset: 0x2430284 VA: 0x2430284
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class SkipjackEngine : IBlockCipher // TypeDefIndex: 4729
{
	// Fields
	private const int BLOCK_SIZE = 8;
	private static readonly short[] ftable; // 0x0
	private int[] key0; // 0x10
	private int[] key1; // 0x18
	private int[] key2; // 0x20
	private int[] key3; // 0x28
	private bool encrypting; // 0x30

	// Properties
	public virtual string AlgorithmName { get; }
	public virtual bool IsPartialBlockOkay { get; }

	// Methods

	// RVA: 0x24302D8 Offset: 0x24302D8 VA: 0x24302D8
	public void .ctor() { }

	// RVA: 0x24302E0 Offset: 0x24302E0 VA: 0x24302E0 Slot: 10
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x243067C Offset: 0x243067C VA: 0x243067C Slot: 11
	public virtual string get_AlgorithmName() { }

	// RVA: 0x24306C4 Offset: 0x24306C4 VA: 0x24306C4 Slot: 12
	public virtual bool get_IsPartialBlockOkay() { }

	// RVA: 0x24306CC Offset: 0x24306CC VA: 0x24306CC Slot: 13
	public virtual int GetBlockSize() { }

	// RVA: 0x24306D4 Offset: 0x24306D4 VA: 0x24306D4 Slot: 14
	public virtual int ProcessBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x24307FC Offset: 0x24307FC VA: 0x24307FC Slot: 15
	public virtual void Reset() { }

	// RVA: 0x2430800 Offset: 0x2430800 VA: 0x2430800
	private int G(int k, int w) { }

	// RVA: 0x2430A88 Offset: 0x2430A88 VA: 0x2430A88 Slot: 16
	public virtual int EncryptBlock(byte[] input, int inOff, byte[] outBytes, int outOff) { }

	// RVA: 0x2430E6C Offset: 0x2430E6C VA: 0x2430E6C
	private int H(int k, int w) { }

	// RVA: 0x24310F4 Offset: 0x24310F4 VA: 0x24310F4 Slot: 17
	public virtual int DecryptBlock(byte[] input, int inOff, byte[] outBytes, int outOff) { }

	// RVA: 0x24314E4 Offset: 0x24314E4 VA: 0x24314E4
	private static void .cctor() { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public class TeaEngine : IBlockCipher // TypeDefIndex: 4730
{
	// Fields
	private const int rounds = 32;
	private const int block_size = 8;
	private const uint delta = 2654435769;
	private const uint d_sum = 3337565984;
	private uint _a; // 0x10
	private uint _b; // 0x14
	private uint _c; // 0x18
	private uint _d; // 0x1C
	private bool _initialised; // 0x20
	private bool _forEncryption; // 0x21

	// Properties
	public virtual string AlgorithmName { get; }
	public virtual bool IsPartialBlockOkay { get; }

	// Methods

	// RVA: 0x2431560 Offset: 0x2431560 VA: 0x2431560
	public void .ctor() { }

	// RVA: 0x2431588 Offset: 0x2431588 VA: 0x2431588 Slot: 10
	public virtual string get_AlgorithmName() { }

	// RVA: 0x24315D0 Offset: 0x24315D0 VA: 0x24315D0 Slot: 11
	public virtual bool get_IsPartialBlockOkay() { }

	// RVA: 0x24315D8 Offset: 0x24315D8 VA: 0x24315D8 Slot: 12
	public virtual int GetBlockSize() { }

	// RVA: 0x24315E0 Offset: 0x24315E0 VA: 0x24315E0 Slot: 13
	public virtual void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x2431830 Offset: 0x2431830 VA: 0x2431830 Slot: 14
	public virtual int ProcessBlock(byte[] inBytes, int inOff, byte[] outBytes, int outOff) { }

	// RVA: 0x2431B84 Offset: 0x2431B84 VA: 0x2431B84 Slot: 15
	public virtual void Reset() { }

	// RVA: 0x24317C0 Offset: 0x24317C0 VA: 0x24317C0
	private void setKey(byte[] key) { }

	// RVA: 0x24319AC Offset: 0x24319AC VA: 0x24319AC
	private int encryptBlock(byte[] inBytes, int inOff, byte[] outBytes, int outOff) { }

	// RVA: 0x2431A9C Offset: 0x2431A9C VA: 0x2431A9C
	private int decryptBlock(byte[] inBytes, int inOff, byte[] outBytes, int outOff) { }
}

// Namespace: Org.BouncyCastle.Crypto.Engines
public sealed class TwofishEngine : IBlockCipher // TypeDefIndex: 4731
{
	// Fields
	private static readonly byte[,] P; // 0x0
	private const int P_00 = 1;
	private const int P_01 = 0;
	private const int P_02 = 0;
	private const int P_03 = 1;
	private const int P_04 = 1;
	private const int P_10 = 0;
	private const int P_11 = 0;
	private const int P_12 = 1;
	private const int P_13 = 1;
	private const int P_14 = 0;
	private const int P_20 = 1;
	private const int P_21 = 1;
	private const int P_22 = 0;
	private const int P_23 = 0;
	private const int P_24 = 0;
	private const int P_30 = 0;
	private const int P_31 = 1;
	private const int P_32 = 1;
	private const int P_33 = 0;
	private const int P_34 = 1;
	private const int GF256_FDBK = 361;
	private const int GF256_FDBK_2 = 180;
	private const int GF256_FDBK_4 = 90;
	private const int RS_GF_FDBK = 333;
	private const int ROUNDS = 16;
	private const int MAX_ROUNDS = 16;
	private const int BLOCK_SIZE = 16;
	private const int MAX_KEY_BITS = 256;
	private const int INPUT_WHITEN = 0;
	private const int OUTPUT_WHITEN = 4;
	private const int ROUND_SUBKEYS = 8;
	private const int TOTAL_SUBKEYS = 40;
	private const int SK_STEP = 33686018;
	private const int SK_BUMP = 16843009;
	private const int SK_ROTL = 9;
	private bool encrypting; // 0x10
	private int[] gMDS0; // 0x18
	private int[] gMDS1; // 0x20
	private int[] gMDS2; // 0x28
	private int[] gMDS3; // 0x30
	private int[] gSubKeys; // 0x38
	private int[] gSBox; // 0x40
	private int k64Cnt; // 0x48
	private byte[] workingKey; // 0x50

	// Properties
	public string AlgorithmName { get; }
	public bool IsPartialBlockOkay { get; }

	// Methods

	// RVA: 0x2431B88 Offset: 0x2431B88 VA: 0x2431B88
	public void .ctor() { }

	// RVA: 0x2432234 Offset: 0x2432234 VA: 0x2432234 Slot: 5
	public void Init(bool forEncryption, ICipherParameters parameters) { }

	// RVA: 0x2433580 Offset: 0x2433580 VA: 0x2433580 Slot: 4
	public string get_AlgorithmName() { }

	// RVA: 0x24335C8 Offset: 0x24335C8 VA: 0x24335C8 Slot: 7
	public bool get_IsPartialBlockOkay() { }

	// RVA: 0x24335D0 Offset: 0x24335D0 VA: 0x24335D0 Slot: 8
	public int ProcessBlock(byte[] input, int inOff, byte[] output, int outOff) { }

	// RVA: 0x2433ED0 Offset: 0x2433ED0 VA: 0x2433ED0 Slot: 9
	public void Reset() { }

	// RVA: 0x2433EE0 Offset: 0x2433EE0 VA: 0x2433EE0 Slot: 6
	public int GetBlockSize() { }

	// RVA: 0x24324A4 Offset: 0x24324A4 VA: 0x24324A4
	private void SetKey(byte[] key) { }

	// RVA: 0x24336FC Offset: 0x24336FC VA: 0x24336FC
	private void EncryptBlock(byte[] src, int srcIndex, byte[] dst, int dstIndex) { }

	// RVA: 0x2433AE0 Offset: 0x2433AE0 VA: 0x2433AE0
	private void DecryptBlock(byte[] src, int srcIndex, byte[] dst, int dstIndex) { }

	// RVA: 0x2434080 Offset: 0x2434080 VA: 0x2434080
	private int F32(int x, int[] k32) { }

	// RVA: 0x2433FE0 Offset: 0x2433FE0 VA: 0x2433FE0
	private int RS_MDS_Encode(int k0, int k1) { }

